[general]
#
# general.domain
#
# Domain name of PacketFence system.
domain=packetfence.org
#
# general.hostname
#
# Hostname of PacketFence system.  This is concatenated with the domain in Apache rewriting rules and therefore must be resolvable by clients.
hostname=packetfence
#
# general.logo
#
# Logo displayed on web pages.
logo=/common/packetfence-cp.png
#
# general.dnsservers
#
# Comma-delimited list of DNS servers.  Passthroughs are created to allow queries to these servers from even "trapped" nodes.
dnsservers=127.0.0.1
#
# general.dhcpservers
#
# Comma-delimited list of DHCP servers.  Passthroughs are created to allow DHCP transactions from even "trapped" nodes.
dhcpservers=127.0.0.1
#
# general.caching
#
# Enable caching of isinternal values. Not recommended on large networks. Disabled by default. 
caching=disabled
#
# general.locale
#
# Locale used for message translation
# more than 1 can be specified
locale=en_US
#
# general.timezone
#
# System's timezone in string format. Supported list:
# http://www.php.net/manual/en/timezones.php
timezone=America/Montreal
#
# general.maintenance_interval
#
# Interval at which Packetfence runs its maintenance tasks.
maintenance_interval=60s


[network]
#
# network.rogueinterval
#
# When rogue DHCP server detection is enabled, this parameter defines how often to email administrators.  With its default 
# setting of 10, it will email administrators the details of the previous 10 DHCP offers.
rogueinterval=10
#
# network.dhcpdetector
#
# If enabled, PacketFence will monitor DHCP-specific items such as rogue DHCP services, DHCP-based OS fingerprinting, computername/hostname 
# resolution, and (optionnally) option-82 location-based information.  The monitored DHCP packets are DHCPDISCOVERs and DHCPREQUESTs - both are broadcasts, 
# meaning a span port is not necessary.  This feature is highly recommended if the internal network is DHCP-based.
dhcpdetector=enabled
#
# network.dhcpoption82logger
#
# If enabled PacketFence will monitor DHCP option82 location-based information.
# This feature is only available if the dhcpdetector is activated.
dhcpoption82logger=disabled
#
#
# This section allows you to configure locally proxied content.  We typically use this to proxy tools like Stinger rather 
# than having to continually download the latest version. Ex:
# 
# <i>tools/stinger.exe=http://download.nai.com/products/mcafee-avert/stng260.exe</i>
# 
# The Stinger utility could then be accessed at https://pfhostname/proxies/tools/stinger.exe.
[proxies]
tools/stinger.exe=http://download.nai.com/products/mcafee-avert/stng260.exe

[trapping]
#
# trapping.range
#
# Comma-delimited list of address ranges/CIDR blocks that PacketFence will monitor/detect/trap on.  Gateway, network, and 
# broadcast addresses are ignored.
range=192.168.0.0/24
#
# trapping.registration
#
# If enabled, nodes will be required to register on first network access.  Further registration options are configured in the 
# registration section.
registration=disabled
#
# trapping.redirtimer
#
# How long to display the progress bar during trap release.  Setting it to a value of 5 or higher is recommended 
# when in arp mode.  Doing so allows the client time to receive and process the redirection ARP sent by PacketFence.
redirtimer=20s
#
# trapping.passthrough
#
# Method by which content is delivered to trapped systems. When set to "proxy", PacketFence uses Apache's reverse proxy 
# functionality and rewrites links. Note that any link to an external resource on the target server will not be properly
# rewritten.
# When set to "iptables", PacketFence creates passthroughs to the content for only those nodes trapped with the 
# corresponding violation.  Be aware that an iptables passthrough is based on IP address and clients will be able to 
# get to ALL content on the destination site.
# When set to "disabled" passthrough is disabled.
passthrough=disabled
#
# trapping.blacklist
#
# Comma-delimited list of MAC addresses that are not allowed to pass through the PacketFence system.
blacklist=
#
# trapping.whitelist
#
# Comma-delimited list of MAC addresses that are immune to isolation. 
# Additionally, in ARP mode no registration/trapping is performed so whitelisted hosts are always allowed to pass.
whitelist=
#
# trapping.redirecturl
#
# Default URL to redirect to on registration/mitigation release. 
#
redirecturl=http://www.packetfence.org/
#
# trapping.always_use_redirecturl
#
# Under most circumstances we can redirect the user to the URL he originally intended to visit.
# When enabled, always_use_redirecturl forces the captive portal to redirect the user to the URL defined in
# trapping.redirecturl instead.
#
always_use_redirecturl=disabled
#
# trapping.detection
#
# Enables snort-based worm detection.  If you don't have a span interface available, don't bother enabling it.  If you do, 
# you'll most definately want this on.
detection=disabled

[registration]
#
# registration.range
#
#
range=
#
# registration.skip_mode
#
# If set to "deadline", the deadline option defines the time at which skipping registration is no longer 
# an option for clients.  If set to "window", the window is used to determine the amount of time after 
# first network access that a node may skip registration.
skip_mode=disabled
#
# registration.skip_deadline
#
# If mode is set to "deadline", this is the date at which the "skip registration" option is disabled.  Date 
# string is formatted as the output of the "date" command is.
skip_deadline=Mon Nov 12 12:00:00 EST 2012
#
# registration.skip_window
#
# The length of time that a node may skip registration.  For instance, setting it to 14 days would allow 
# students to skip registration for two weeks, giving them time to get a student ID, password, etc.
skip_window=14d
#
# registration.skip_reminder
#
# Interval that a user is re-prompted to register after skipping.  For example, if skip_window=2w and skip_reminder=1d,
# a user will be allowed to skip for two weeks but will be re-prompted every day.
skip_reminder=1d
#
# registration.auth
#
# Method by which registering nodes will be authenticated.  Templates for LDAP, RADIUS, Kerberos, local and guests are 
# available at <conf_dir>/authentication.  If you wish to use a different authentication mechanism, simply create 
# a file called <conf_dir>/authentication/<authname>.pm, fill it with the necessary data, and set 
# auth=<authname>.  The default value, local, relies on a local access file in <conf_dir>/user.conf.
auth=local

#
# registration.default_auth
#
# Authentication method selected as the default in the captive portal drop-down. Only useful if you have more than
# one authentication method (registration.auth).
default_auth=

#
# registration.expire_mode
#
# If set to "deadline", the expire_deadline option defines the date at
# which a node reverts to an unregistered state.  If set to "window",
# the window is used to determine the length of time after registration
# that a node remains registered.  If set to "session", it specifies
# that a client should be unregistered as soon as its iplog entry closes
# (or with a bit of latency - check regitration.expire_session).
expire_mode=disabled
#
# registration.expire_deadline
#
# If expire_mode is set to "deadline", this is the date (formatted as returned by the "date" command) at which 
# nodes revert to an unregistered state.  This would typically be the end of a semester.
expire_deadline=Mon Nov 12 12:00:00 EST 2012
#
# registration.expire_window
#
# If expire_mode is set to "window", this is length of time after
# registration that a node reverts to an unregistered state.
expire_window=52w
#
# registration.expire_session
# If expire_mode is set to "session", this is the amount of time after
# a node's iplog entry is closed that it reverts to an unregistered
# state.
# Warning: Does not work in vlan isolation mode!
expire_session=5m
#
# registration.maxnodes
#
# If defined, the maximum number of nodes that can be registered to a single PID.
maxnodes=0
#
# registration.button_text
#
#
button_text=Register
#
# registration.nbregpages
#
# The number of registration pages to show to the user
nbregpages=0


[guests]
#
# guests.self_allow_localdomain
#
# Accept self-registration with email address from the local domain
self_allow_localdomain=enabled

#
# This section allows you to create passthroughs to HTML content or remote addresses/networks.
# With passthrough=proxy under [trapping] it will support domain names.
# With passthrough=iptables under [trapping] it will support domain names and IP ranges. Note that this implementation 
# is unmaintained and might not work.
#
# Here's an example:
# packetfence=http://www.packetfence.org
# The above will allow 80/tcp traffic to the packetfence domain (the left value is arbitrary).
# Passthroughs can also take the form of:
# test=192.168.100.10/23
# which would allow full IP to all 512 destination addresses. Unsupported in trapping.passhtrough=proxy.
# 
[passthroughs]

[alerting]
#
# alerting.emailaddr
#
# Email address to which notifications of rogue DHCP servers, violations with an action of "email", or any other 
# PacketFence-related message goes to.
emailaddr=pf@localhost
#
# alerting.smtpserver
#
# Server through which to send messages to the above emailaddr.  The default is localhost - be sure you're running an SMTP 
# host locally if you don't change it!
smtpserver=localhost
#
# alerting.subjectprefix
#
#Subject prefix for email notifications of rogue DHCP servers, violations with an action of "email", or any other
#PacketFence-related message.
subjectprefix=PF Alert:
#
# alerting.log
#
# Log file where "log" actions are sent.
log=violation.log
#
# alerting.wins_server
#
# WINS server to  resolve NetBIOS name of administrative workstation to IP address.
wins_server=192.168.0.100
#
# alerting.admin_netbiosname
#
# NetBIOS name of administrative workstation to send alerts with "winpopup" action assigned.
admin_netbiosname=EXAMPLE

[ports]
#
# ports.listeners
#
# Enables "bogus" IMAP and POP servers.  These servers serve only to deliver a message (POP3) or send an alert (IMAP) to
# inform the user that he/she must register before connectivity is allowed.  Content of the message is found at 
# <conf_dir>/listener.msg
listeners=
#
# ports.admin
#
# Port the administrative interface listens on.
admin=1443

[scan]
#
# scan.ssl
#
# enable ssl communication with the nessus server.   
ssl=enabled
#
# scan.pass
#
# Password to log into nessus server with.
pass=packet
#
# scan.user
#
# Username to log into nessus server with.
user=admin
#
# scan.port
#
# Port nessus server is running on.
port=1241
#
# scan.host
#
# Host the nessus server is running on.  For performance reasons, we recommend running the nessus server remotely.  A 
# passthrough will be automagically created.
host=127.0.0.1
#
# scan.registration
#
# If this option is enabled, pf will scan each host after registration is complete with all nessusids.
registration=disabled
#
# scan.nessusclient_file
#
# Name of the NessusClient file; the file format is documented at
# http://www.nessus.org/documentation/dot_nessus_file_format.pdf
# This file must be found in conf/nessus/
nessusclient_file=remotescan.nessus
#
# scan.nessusclient_policy
#
# Name of the policy inside the NessusClient file
nessusclient_policy=RemoteScan
#
# scan.duration
#
# Approximate duration of a scan. User being scanned on registration are presented a progress bar 
# for this duration, afterwards the browser refreshes until scan is complete.
duration=60s
#

[database]
#
# database.pass
#
# Password for the mysql database used by PacketFence.
pass=packet
#
# database.db
#
# Name of the mysql database used by PacketFence.
db=pf
#
# database.user
#
# Username of the account with access to the mysql database used by PacketFence.
user=pf
#
# database.port
#
# Port the mysql server is running on.
port=3306
#
# database.host
#
# Server the mysql server is running on.
host=localhost

[expire]
# TODO: validate that this only works in ARP mode or not
#
# expire.node
#
# Time before a node is removed due to inactivity.
# A value of 0d disables expiration.
# example:
# node=90d
node=0d
#
# expire.iplog
#
# Time which you would like to keep logs on IP/MAC information.
# A value of 0d disables expiration.
# example:
# iplog=180d
iplog=0d
#
# expire.traplog
#
# Time which you would like to keep logs on trap information.
# A value of 0d disables expiration.
# example:
# traplog=180d
traplog=0d
#
# expire.locationlog
#
# Time which you would like to keep logs on location information
# Please note that this table should not become too big since it 
# could degrade pfsetvlan performance.
# A value of 0d disables expiration.
# example:
# locationlog=180d
locationlog=0d

[services]
#
# services.dhcpd
#
# Should DHCPd be managed by PacketFence?
dhcpd=enabled
#
# services.named
#
# Should named be managed by PacketFence?
named=enabled
#
# services.radiusd
#
# Should radiusd be managed by PacketFence?
radiusd=enabled
#
# services.snort_binary
#
# Location of the snort binary. Only necessary to change if you are not running the RPMed version. 
snort_binary=/usr/sbin/snort
#
# services.httpd_binary
#
# Location of the apache binary. Only necessary to change if you are not running the RPMed version.
httpd_binary=/usr/sbin/httpd
#
# services.dhcpd_binary
#
# Location of the dhcpd binary. Only necessary to change if you are not running the RPMed version.
dhcpd_binary=/usr/sbin/dhcpd
#
# services.named_binary
#
# Location of the named binary. Only necessary to change if you are not running the RPMed version.
named_binary=/usr/sbin/named
#
# services.snmptrapd_binary
#
# Location of the snmptrapd binary. Only necessary to change if you are not using the RPMed version.
snmptrapd_binary=/usr/sbin/snmptrapd
# 
# services.radiusd_binary
# 
# Location of the named binary. Only necessary to change if you are not running the RPMed version.
radiusd_binary=/usr/sbin/radiusd

[vlan]
#
# vlan.closelocationlogonstop
#
# Should open locationlog entries be closed when pfsetvlan is 
# stopped
closelocationlogonstop=disabled
#
#
# vlan.nbtraphandlerthreads
#
# Number of trap handler threads pfsetvlan should start
nbtraphandlerthreads = 20
#
# vlan.nbtrapparserthreads
#
# Number of trap parser threads pfsetvlan should start
nbtrapparserthreads = 5
#
# vlan.bounce_duration
#
# Delay to wait between the shut / no-shut on a port. Some OS need a higher value than others.
# Default should be reasonable for almost every OS but is too long for the usual proprietary OS.
bounce_duration = 4s


[inline]
#
# inline.ports_redirect
#
# Ports to intercept and redirect for trapped and unregistered systems.  Defaults to 80/tcp (HTTP), 443/tcp (HTTPS).
# Redirecting 443/tcp (SSL) will work, although users might get certificate errors if you didn't install a valid 
# certificate or if you don't use DNS (although IP-based certificates supposedly exist)
# Redirecting 53/udp (DNS) seems to have issues and is also not recommended.
# We also have experimental IMAP and POP3 listeners which give fake emails telling users to open their browsers.
# Enable them via the ports.listeners parameter and add the IMAP (143/tcp) and POP3 (110/tcp) here.
ports_redirect=80/tcp,443/tcp
#
# inline.portal_redirect
#
# How should we refer to the captive portal in inline mode? Using DNS means that 
# you need to configure your DNS to point to the PacketFence IP on the inline 
# interface but allows you to easily use an SSL certificate for https.
portal_redirect=ip


[servicewatch]
#
# servicewatch.email
#
# should pfcmd service pf watch send an email if services are not running
email=enabled
#
# servicewatch.restart
#
# should pfcmd service pf watch restart PF if services are not running
restart=disabled

[captive_portal]
#
# captive_portal.network_detection_ip
#
# This IP is used as the webserver who hosts the common/network-access-detection.gif which is used to detect if network
# access was enabled. 
# It cannot be a domain name since it is used in registration or quarantine where DNS is blackholed.
# It is recommended that you allow your users to reach your packetfence server and put your LAN's PacketFence IP.
# By default we will make this reach PacketFence's website as an easy solution.
#
network_detection_ip = 67.205.85.245

[advanced]
#
# advanced.reevaluate_access_reasons
#
# After which calls to pfcmd do we have to re-evaluate the state of a node and re-assign VLAN or change iptables rules
reevaluate_access_reasons=node_modify,manage_register,manage_deregister,manage_vclose,manage_vopen,violation_modify,violation_add,violation_delete,redir.cgi
#
# advanced.adjustswitchportvlanscript
#
# Which script do we have to execute to adjust the switchport VLAN
adjustswitchportvlanscript=pfcmd_vlan

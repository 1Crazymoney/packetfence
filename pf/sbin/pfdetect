#!/usr/bin/perl

=head1 NAME

pfdetect - listen to snort alerts and create PF violations

=head1 SYNOPSIS

pfdetect -p <snortpipe> [options]

 Options:
   -d     Daemonize
   -h     Help

=cut

use Getopt::Std;
use File::Basename qw(basename);
use strict;
use warnings;
use Log::Log4perl;

use constant INSTALL_DIR => '/usr/local/pf';

use lib INSTALL_DIR . "/lib";
use pf::db;
use pf::config;
use pf::iplog;
use pf::util;
use pf::violation;
use pf::trigger;
use pf::node;
use pf::class;
use pf::action;
use pf::os;
use pf::person;

Log::Log4perl->init( INSTALL_DIR . "/conf/log.conf" );
my $logger = Log::Log4perl->get_logger( basename($0) );
Log::Log4perl::MDC->put( 'proc', basename($0) );
Log::Log4perl::MDC->put( 'tid',  0 );

$SIG{'HUP'} = \&restart_handler;

my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'dhp:', \%args );

usage() if ( $args{h} || !$args{p} );

my $daemonize = $args{d};
my $snortpipe = $args{p};
my $script    = basename($0);

my ( $line, $sid, $descr, $priority, $date, $srcmac, $srcip, $dstip, $mydbh );

daemonize() if ($daemonize);

$logger->info("initialized");

my $snortpipe_fh;
if ( !open( $snortpipe_fh, '<', "$snortpipe" ) ) {
    $logger->logdie("unable to open snort pipe: $!");
} else {
    $logger->info("listening on $snortpipe");
}

while (<$snortpipe_fh>) {

    $logger->info("alert received: $_");
    if ( $_
        =~ /^(.+?)\s+\[\*\*\]\s+\[\d+:(\d+):\d+\]\s+(.+?)\s+.+?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(:\d+){0,1}\s+\-\>\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(:\d+){0,1}/
        )
    {
        $date  = $1;
        $sid   = $2;
        $descr = $3;
        $srcip = $4;
        $dstip = $6;
    } elsif ( $_
        =~ /^(.+?)\s+\[\*\*\]\s+\[\d+:(\d+):\d+\]\s+Portscan\s+detected\s+from\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/
        )
    {
        $date  = $1;
        $sid   = $portscan_sid;
        $srcip = $3;
        $descr = "PORTSCAN";
    } elsif ( $_
        =~ /^(.+?)\[\*\*\] \[\d+:(\d+):\d+\]\s+\(spp_portscan2\) Portscan detected from (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/
        )
    {
        $date  = $1;
        $sid   = $portscan_sid;
        $srcip = $3;
        $descr = "PORTSCAN";
    } else {
        $logger->warn("unknown input: $_ ");
        next;
    }

    db_connect(
        $mydbh, 'iplog',  'violation', 'trigger',
        'node', 'action', 'class',     'os',
        'person'
    );
    $srcmac = ip2mac($srcip);

    if ($srcmac) {
        $logger->info("pfdetect: violation $sid [$descr]: $srcmac");
        if (   valid_mac($srcmac)
            && !whitelisted_mac($srcmac)
            && trappable_ip($srcip)
            && trappable_mac($srcmac) )
        {

            #violation_trigger($srcmac, $sid, "detect");
            `/usr/local/pf/bin/pfcmd violation add vid=$sid,mac=$srcmac`;
        } else {
            $logger->info(
                "violation $sid [$descr]: $srcmac not added, host is not trappable, or whitelisted"
            );
        }
    } else {
        $logger->warn(
            "pfdetect: $srcip MAC NOT FOUND for violation $sid [$descr]");
    }

}

END {
    deletepid();
    $logger->info("stopping pfdetect");
    close($snortpipe_fh);
}

exit(0);

sub daemonize {
    createpid();
    chdir '/' or $logger->logdie("Can't chdir to /: $!");
    open STDIN, '<', '/dev/null'
        or $logger->logdie("Can't read /dev/null: $!");
    open STDOUT, '>', '/dev/null'
        or $logger->logdie("Can't write to /dev/null: $!");

    defined( my $pid = fork )
        or $logger->logdie("pfdetect: could not fork: $!");
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        $logger->warn("could not start a new session: $!");
    }
    open STDERR, '>&STDOUT' or $logger->logdie("Can't dup stdout: $!");
}

sub normal_sighandler {
    deletepid();
    $logger->logdie( "caught SIG" . $_[0] . " - terminating" );
}

sub restart_handler {
    deletepid();
    $logger->info( "caught SIG" . $_[0] . " - restarting" );
    if ( !exec( $0, @ORIG_ARGV ) ) {
        logger->logdie("could not restart: #!");
    }
}

sub usage {
    my $cmd = basename($0);
    print STDERR << "EOF";
  Usage: $cmd -p snortpipe [OPTIONS]

  Options:
        -d  Daemonize
        -h  Help
EOF
    exit;
}

=head1 AUTHOR

Dave Laporte <dave@laportestyle.org>

Kevin Amorin <kev@amorin.org>

=head1 COPYRIGHT

Copyright (C) 2005 Dave Laporte

Copyright (C) 2005 Kevin Amorin

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut


#!/usr/bin/perl 
#
# Copyright 2005 Dave Laporte <dave@laportestyle.org>
# Copyright 2005 Kevin Amorin <kev@amorin.org>
#
# See the enclosed file COPYING for license information (GPL).
# If you did not receive this file, see
# http://www.fsf.org/licensing/licenses/gpl.html.
#

use warnings;
use strict;
use Getopt::Std;
use Net::RawIP qw(:pcap);
use threads;
use threads::shared;
use POSIX qw(:signal_h);

Log::Log4perl->init('/usr/local/pf/conf/log.conf');
my $logger = Log::Log4perl->get_logger('pfmon');
Log::Log4perl::MDC->put('proc', 'pfmon');


use lib '/usr/local/pf/lib';
use pf::config;
use pf::iplog;

#$thread=1;

use pf::db;
use pf::util;
use pf::person;
use pf::node;
use pf::class;
use pf::violation;
use pf::trigger;
use pf::services;
use pf::os;
use pf::action;
use pf::iptables;
use pf::nodecache;
use pf::rawip;
use pf::locationlog;

POSIX::sigaction(&POSIX::SIGHUP,
          POSIX::SigAction->new(
                                'restart_handler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfmon: could not set SIGHUP handler: $!\n";

POSIX::sigaction(&POSIX::SIGTERM,
          POSIX::SigAction->new(
                                'normal_sighandler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfmon: could not set SIGTERM handler: $!\n";

POSIX::sigaction(&POSIX::SIGINT,
          POSIX::SigAction->new(
                                'normal_sighandler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfmon: could not set SIGINT handler: $!\n";

my @ORIG_ARGV = @ARGV;

my %args;
getopts('dhvr', \%args);

usage() if ($args{h});

my $daemonize = $args{d};
my $verbose   = $args{v};
my $restart   = $args{r};
my %violations : shared;

# Strobe Global flag 
my $strobe_done : shared;
$strobe_done = 0;

# Rearp flag
my $rearp_flag : shared;
$rearp_flag = 0;

our $arp_signal : shared;
$arp_signal = 0;

# It's so hard to say goodbye
my $last_goodbye;

my $arp_interval = $Config{'arp'}{'interval'};

#my $eth = $Config{'arp'}{'listendevice'};
my @kids;

my $cache = pf::nodecache->new();

# standard signals and daemonize
daemonize() if ($daemonize);

# thread off violation updater
if ($Config{'network'}{'mode'} =~ /^passive$/i) {
 push @kids, threads->create(\&arp_gun);
}

if ( $Config{'network'}{'mode'}=~/^dhcp$/i ) {
  $logger->info( "DHCP scope changer enabled");
  push @kids, threads->create( \&dhcp_scoper );
}

# thread off arp listener
if ( $Config{'network'}{'mode'}=~/^passive$/i){
  foreach my $dev (@listen_ints){
    logger->info("ARP detector on $dev enabled");
    push @kids, threads->create( \&arp_detector, $dev );
  }
}

# thread off the cleanup function
push @kids, threads->create(\&cleanup);

$kids[$#kids]->join();
$logger->error("cleanup thread finished - this is bad");

END {
  deletepid();
  $logger->info("stopping pfmon");
  if ($Config{'network'}{'mode'}=~/passive/i) {
    # wake up the arpgun... then kill him
    foreach my $kid (@kids){
      $kid->detach;
    }
  }
  # killing kids ain't fun, but somebody's got to do it...
  kill 6,-$$;
}

exit(0);

sub arp_detector {
  my ($eth) = @_;          
  my $logger = Log::Log4perl::get_logger('pfmon::arp_detector');
  Log::Log4perl::MDC->put('tid', threads->self->tid());
  my $packet_arp = new Net::RawIP;
  my $filter = arp_filter();
  my $pcap_arp = $packet_arp->pcapinit($eth,$filter,1500,30);
  $logger->info("starting arp detector on $eth");
  my $mydbh=0;
  while(1) {
    my $tmp;
    my $packet = &next($pcap_arp, $tmp);
    db_connect($mydbh,'iplog','node');
    listen_arp($packet) if ($packet);
  }
}



sub dhcp_scoper {
  my $mydbh;
  my $logger = Log::Log4perl::get_logger('pfmon::dhcp_scoper');
  Log::Log4perl::MDC->put('tid', threads->self->tid());
  db_connect($mydbh,'node','violation');

  my %isolated;   
  my %oldisolated;
  my %registered;
  my %oldregistered;
  my $isoflag = 0;
  my $regflag = 0;

  if (service_ctl("dhcpd","status")==0){
    $logger->error("ERROR - DHCP IS NOT RUNNING - EXIT");
    exit 1;
  }

  #every 30 seconds check to see if a host has changed status
  #
  while (1) {
    # is iso enabled
    if ( !isenabled( $Config{'trapping'}{'testing'} ) ) {
      foreach my $row ( violation_view_open_uniq() ) {
        my $hostname = $row->{'mac'};
        $hostname =~ s/://g;
        $isolated{$hostname}=1;
        $isoflag = 1 if ( !defined $oldisolated{$hostname} );
      }
      foreach my $key (keys %oldisolated){
	    $isoflag=1 if (!defined $isolated{$key});
      }
    }

    # is registration is enabled
    if ( isenabled( $Config{'trapping'}{'registration'} ) ) {
      foreach my $row ( nodes_registered_not_violators() ) {
        my $hostname = $row->{'mac'};
        $hostname =~ s/://g;
        $registered{$hostname}=1;
        $regflag = 1 if ( !defined $oldregistered{$hostname} );
      }
      foreach my $key (keys %oldregistered){
	    $regflag=1 if (!defined $registered{$key});
      }
    }

    if ($regflag || $isoflag){
       #regen files if necessary
       $logger->info("Regen DHCP Reg/Iso Files and Restart");
       generate_dhcpd_reg() if ($regflag);
       generate_dhcpd_iso() if ($isoflag);

       # stop dhcp - DIE DIE
       do {service_ctl("dhcpd","stop"); sleep(2); } while (service_ctl("dhcpd","status")!=0);

       # start dhcp
       do {service_ctl("dhcpd","start",1); sleep (2); } while (service_ctl("dhcpd","status")==0);
    }

    #reset vars for loop
    %oldisolated   = %isolated;
    %oldregistered = %registered;
    %isolated      = ();
    %registered    = ();
    $regflag       = 0;
    $isoflag       = 0;
    $logger->info("sleeping 30 seconds");
    sleep(30);
  }

}


sub listen_arp {
  my ($type,$srcmac,$srcip,$destmac,$destip)=&decode(@_);
  return if (!isinternal($srcip));
 
  if ($type == 1) {
    $logger->debug("ARP who-has $destip tell $srcip  $srcmac $srcip $destmac $destip");
    my $gip = ip2gateway($srcip);
    if (valid_ip($srcip) && valid_ip($gip) && ($srcip eq $gip)) {
      if ($destmac =~ /ff:ff:ff:ff:ff:ff/i || $destmac =~ /00:00:00:00:00:00/i) {
        $logger->info("broadcast arp request from router for $destip - re-trapping all nodes");
	  }elsif (!grep(/^$monitor_int$/,@listen_ints)){
        $logger->info("flooded arp request from router for $destmac ($destip) - re-trapping all nodes");
      } else {
        $logger->debug("arp request from router for $destmac ($destip)");
        return;
      }

      # stuff router cache with our MAC for unresponsive addresses
      if (!$cache->ip_exist($destip) && $strobe_done && isenabled($Config{'arp'}{'stuffing'}) && trappable_ip($destip)) {
        $logger->info("host $destip not in hash, forging ARP reply");
        arpmac($blackholemac,$destip,ip2mac($gip),$gip,0,2); 
      }

      {
        #mark the rearp flag
        $logger->debug("setting rearp flag == 1");
        $logger->trace("trying to obtain lock on \$rearp_flag in listen_arp sub");
        lock($rearp_flag);
        $rearp_flag=1;
        $logger->trace("releasing lock on \$rearp_flag in listen_arp sub");
      }

      #wake up the arpgun thread
      $logger->debug("sending signal to arp_gun (if he is sleeping)");
      {
        $logger->trace("trying to obtain lock on \$arp_signal in listen_arp sub");
        lock($arp_signal);
        cond_signal($arp_signal);
        $logger->trace("releasing lock on \$arp_signal in listen_arp sub");
      }
    } else{
       #util_funnyarp($srcmac,$srcip,$destmac,$destip,$type);
    }

    $logger->trace("trying to obtain lock on \%violations in listen_arp sub");
    lock(%violations);
    #  if a violation host arp them now!
    if ($violations{$srcmac}){
      $logger->info("$srcmac ($srcip) is arping for $destip");
      trapmac($srcmac) if ($destip eq $gip);
    }
    update_hashes($srcmac,$srcip);
    $logger->trace("releasing lock on \%violations in listen_arp sub");

  } elsif ($type == 2) {
    $logger->debug("ARP $srcip is-at $srcmac $srcmac $srcip $destmac $destip");
    update_hashes($srcmac,$srcip);
    #util_funnyarp($srcmac,$srcip,$destmac,$destip,$type);
  } 
}




# 
#
sub arp_gun {
  my $logger = Log::Log4perl::get_logger('pfmon::arp_gun');
  Log::Log4perl::MDC->put('tid', threads->self->tid());
   
  $logger->info("Starting ARP gun thread");
  #lock($arp_signal);
  my $mydbh=0;

  $last_goodbye=time();

  # don't start shooting till the DB is populated 
  sleep($arp_interval);

  while(1) {
    db_connect($mydbh,'iplog','node','violation');
    #reset the flag as we are going to arp now
    if ($rearp_flag){
      $logger->debug("resetting flag and ARPing");
      $logger->trace("trying to obtain lock on \$rearp_flag in arp_gun sub");
      lock($rearp_flag);
      $rearp_flag=0;
      $logger->trace("releasing lock on \$rearp_flag in arp_gun sub");
    }
    rearp();

    # has the flag been set while we were arping??? if no flag sleep for $arp_interval
    if (!$rearp_flag){
      $logger->info("sleeping for $arp_interval seconds");
      lock($arp_signal);
      if (cond_wait( $arp_signal)) {
        $logger->info("cleanup/listen_arp woke us up");
      }
    }
  }
}

sub hello {
  my @tmpv = @_;
  $logger->info(scalar(@tmpv)." node(s) ") if (scalar(@tmpv) > 1);

  for my $row (@tmpv) {
    my $mac = $row->{'mac'};
    my $ip = $row->{'ip'};
    #  arp from my ip please
    my $intip = ip2interface($ip);
    my $mymac = getlocalmac(ip2device($ip));
    if ($mac=~/ff:ff:ff:ff:ff:ff/ || trappable_mac($mac)) {
      arpmac($mymac,$intip,$mac,$ip,0,1);
      $logger->debug("heartbeat sent to $mac ($ip)");
    }
  }

}

sub goodbye {
  my @tmpv = @_;
  my $heartbeat =$Config{'arp'}{'heartbeat'};
  my @deadnodes;
  $logger->info(scalar(@tmpv)." node(s) - heartbeat = $heartbeat") if (scalar(@tmpv) > 0);

  for my $row (@tmpv) {
    my $mac = $row->{'mac'};
    my $ip = $row->{'ip'};

    if (trappable_ip($ip) && trappable_mac($mac)) {
      my $diff = $cache->get_arptime($mac);
      if ($diff <= $heartbeat ){
        $logger->info("trapping $mac last seen $diff seconds ago");
        trapmac($mac);
      }else{
	    $logger->info("$mac timeout : $diff");
        hello({'ip'=>$ip,'mac'=>$mac});
        push(@deadnodes,$mac); 
      }
    }
  }

  return(@deadnodes);
}


sub rearp {
  my %new_violations=();
  my $newflag=0;

  #check the db handle every arp_interval

  my @violators = violation_view_all_active();

  foreach my $row (@violators) {
    my $mac = $row->{'mac'};
    my $ip = $row->{'ip'};
    $new_violations{$mac}=$ip;
    $newflag=1 if (!$violations{$mac});
  }

  # update the violations hash for other threads
  {
    $logger->trace("trying to obtain lock on \%violations in rearp sub");
    lock(%violations);
    %violations=();
    %violations=%new_violations;
    $logger->trace("releasing lock on \%violations in rearp sub");
  }

  if (scalar(@violators) > 0) {
    #
    # say hello if we haven't said goodbye in the last heartbeat/2 sec (usally 15sec) or 
    #     a new host is in violation
    #
    my $mytime = time()-$last_goodbye;
    if ($newflag || $mytime > ($Config{'arp'}{'heartbeat'})/2){
      $logger->info("Saying hello, last goodbye time was $mytime [$newflag] sec");
      hello(@violators);
      # sleep 2 sec to give listen arp time to catch up
      sleep(2);
    } else{
      $logger->info("No hello, last goodbye was $mytime [$newflag] sec");
    }
    goodbye(@violators);
    $last_goodbye=time();
  }

}

sub cleanup {
  my $logger = Log::Log4perl::get_logger('pfmon::cleanup');
  Log::Log4perl::MDC->put('tid', threads->self->tid());
  $logger->info("Starting cleanup thread");
  my $mydbh;
  db_connect($mydbh,'iplog','node','locationlog');

  if (!$restart) {
    $logger->info("closing open iplogs (just in case)");
    iplog_shutdown();
  } else {
    $logger->info("restarted - leaving iplogs open and re-creating hashes");
    my @iplogs = iplog_view_open();
    for my $row (@iplogs) {
      my $mac = $row->{'mac'};
      my $ip  = $row->{'ip'};
      $logger->info("re-populating hashes $mac<->$ip");
      $cache->new_node($mac,$ip);
    }
  }

  # strobe if we are not DHCP
  #
  if ($Config{'network'}{'mode'}!~/^dhcp$/){
    # wait until listen_arp is ready
    sleep ($arp_interval);

    # make sure we get gateways
    foreach my $gateway (get_gateways()) {
      $logger->info("ARPing gateway $gateway");
      hello({'ip'=>$gateway,'mac'=>"ff:ff:ff:ff:ff:ff"});
    }

    strobe() if(isenabled($Config{'arp'}{'strobe'}) || isenabled($Config{'arp'}{'stuffing'}));
  }

  my $counter=0;
  while (1) {
    db_connect($mydbh,'iplog','node','locationlog');
    $counter=($counter+1) % 10;
    #
    # delete expired nodes 
    $cache->delete_expired($Config{'arp'}{'timeout'});

    #
    # say hello before expiring nodes
    if ($Config{'network'}{'mode'}!~/^dhcp$/){
      my @macs = $cache->hello_macs($Config{'arp'}{'timeout'},$arp_interval);
      foreach my $mac (@macs){
        hello({'ip'=>$cache->get_ip($mac),'mac'=>$mac});
      }
    }

    #
    # run these functions every $arp_interval * 10 
    if ($counter==0){
      $logger->info("running expire check");
      iplog_cleanup($Config{'expire'}{'iplog'}) if ($Config{'expire'}{'iplog'});
      locationlog_cleanup($Config{'expire'}{'locationlog'}) if ($Config{'expire'}{'locationlog'});
      node_cleanup($Config{'expire'}{'node'}) if ($Config{'expire'}{'node'});
      $logger->info("checking registered nodes for expiration");
      nodes_maintenance();
    }      

    sleep $arp_interval;
    if ($Config{'network'}{'mode'}!~/^dhcp$/i) {
      $logger->trace("trying to obtain lock on arp_signal in cleanup sub");
      lock($arp_signal);
      cond_signal($arp_signal);
      $logger->trace("releasing lock on arp_signal in cleanup sub");
    } 
  }
}

sub update_hashes {
  my ($srcmac,$srcip,$lease_length)=@_;
  $logger->debug("$srcip && $srcmac");

  # return if MAC or IP is not valid
  if (!valid_mac($srcmac) || !valid_ip($srcip)) {
    $logger->error("invalid MAC or IP: $srcmac $srcip");
    return;
  }

  #DB is out of date with Cache
  if (!node_exist($srcmac) && $cache->get_ip($srcmac)){
     $logger->info("$srcmac ($srcip) does not exist in the Database - Deleting from cache");
     $cache->delete_node($srcmac);
  }

  my $oldmac=$cache->get_mac($srcip);

  if ($oldmac eq $srcmac){

     $logger->debug("oldmac and newmac ($srcmac) are the same for $srcip");
     if (! defined(iplog_view_open_mac($srcmac))) {
       $logger->debug("inserting $srcip ($srcmac) into iplog table");
       iplog_open($srcmac,$srcip,$lease_length);
     } elsif ($lease_length) {
       $logger->debug("updating end_time for $srcip ($srcmac) in iplog table");
       iplog_open($srcmac,$srcip,$lease_length);
     }

     $cache->set_arptime($srcmac);
     node_update_lastarp($srcmac);
     return;
  }

  my $oldip=$cache->get_ip($srcmac);

  if ($oldip && !$oldmac && $Config{'network'}{'mode'}!~/dhcp/i){
    $logger->info("new IP: $srcmac ($srcip) - adding to iplog");
    $cache->add_ip($srcmac,$srcip,$lease_length);
    node_update_lastarp($srcmac);
    return;
  }

  $cache->delete_node($oldmac) if ($oldmac);
  $cache->delete_node($srcmac) if ($oldip);

  if (!$cache->get_ip($srcmac)){
    $logger->info("UPDATE New node $srcmac ($srcip)");
    node_add_simple($srcmac) if (!$oldip);
    $cache->new_node($srcmac,$srcip,$lease_length);
  }else{
    $logger->warn("NOT ADDING NODE $srcmac $srcip could not age out ($oldmac,$oldip)");
  }
} 


sub decode {
  my $pkt=shift; 
  my ($m1,$m2,$proto,$hwas,$pas,$hwal,$pal,$opcode,$sha,$spa,$tha,$tpa)=unpack('H12H12nnnCCnH12NH12N', $pkt);
  return ($opcode,clean_mac($sha),int2ip($spa),clean_mac($tha),int2ip($tpa));
}

sub arp_filter {
  my $filter = "arp net (".join(" or ",get_internal_nets()).")";
  foreach my $mac (get_internal_macs()) {
    $filter .= " and not ether src $mac";
  }
  $filter .= " and not ether src ".$blackholemac;
  return($filter);
}

sub strobe {
  $logger->info("strobing all internal IPs");
  foreach my $ip (get_all_internal_ips()){
    my $intip = ip2interface($ip);
    my $mymac = getlocalmac(ip2device($ip));
    $logger->debug("Strobe $ip [$intip $mymac]");
    arpmac($mymac,$intip,"ff:ff:ff:ff:ff:ff",$ip,0,1);
  }
  sleep($Config{'arp'}{'heartbeat'});
  $strobe_done++;
  $logger->info("strobe complete, network map should be up to date");
}

sub daemonize {
  chdir '/'               or die "Can't chdir to /: $!";
  open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
  my $log_file = '/usr/local/pf/logs/pfmon';
  open STDOUT, ">>$log_file" or die "Can't write to $log_file: $!";

  defined(my $pid = fork) or die "pfmon: could not fork: $!";
  POSIX::_exit(0) if ($pid);
  if (!POSIX::setsid()) {
    $logger->error("could not start a new session: $!");
#    die("pfmon: could not start a new session: $!\n");
  }
  open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
  createpid();
}

sub normal_sighandler {
  deletepid(); 
  if (threads->self->tid() == 0) {
    $logger->info("caught SIG".$_[0]." - closing open iplogs and untrapping");

    my $mydbh;
    db_connect($mydbh,'iplog','node','violation');

    if (isenabled($Config{'arp'}{'cleanshutdown'})) {
      my @violators = violation_view_all_active();  
      foreach my $violator (@violators) {
        freemac($violator->{'mac'});
      }
    }
    iplog_shutdown;
    die("pfmon: caught SIG".$_[0]." - terminating\n");
  }
}

sub restart_handler {
  deletepid();
  $logger->info("caught SIG".$_[0]." - restarting");
  push @ORIG_ARGV, "-r" if(!grep(/^\-r$/,@ORIG_ARGV));
  if (!exec($0, @ORIG_ARGV)) {
    $logger->error("could not restart: #!");
    die "pfmon: could not restart: $!\n";
  }
}

sub usage {
  print STDERR << "EOF";
  Usage: $0 [OPTIONS]
        -d      Daemonize
        -v      Verbose
        -h      Help
EOF
  exit;
}

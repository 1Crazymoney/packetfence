#!/usr/bin/perl
#
# $Id: pfredirect,v 1.3 2005/11/30 21:40:08 kevmcs Exp $
#
# Copyright 2005 Dave Laporte <dave@laportestyle.org>
# Copyright 2005 Kevin Amorin <kev@amorin.org>
#
# See the enclosed file COPYING for license information (GPL).
# If you did not receive this file, see
# http://www.fsf.org/licensing/licenses/gpl.html.
#

use strict;
use Getopt::Std;
use IO::Socket::INET;
use threads;
use threads::shared;
use POSIX();

use lib '/usr/local/pf/lib';
use pf::config;
use pf::util;

POSIX::sigaction(&POSIX::SIGHUP,
          POSIX::SigAction->new(
                                'restart_handler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfredirect: could not set SIGHUP handler: $!\n";

POSIX::sigaction(&POSIX::SIGTERM,
          POSIX::SigAction->new(
                                'normal_sighandler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfredirect: could not set SIGTERM handler: $!\n";

POSIX::sigaction(&POSIX::SIGINT,
          POSIX::SigAction->new(
                                'normal_sighandler',
                                POSIX::SigSet->new(),
                                &POSIX::SA_NODEFER
                               )
         ) or die "pfredirect: could not set SIGINT handler: $!\n";

my @ORIG_ARGV = @ARGV;

my %args;
getopts('dhv', \%args);

usage() if ($args{h});
my $daemonize = $args{d};
my $verbose   = $args{v};

daemonize() if ($daemonize);
pflogger("initialized", 1);

my $pop3_port = 110;
my $imap_port = 143;
my $hostname  = $Config{'general'}{'hostname'} . "." . $Config{'general'}{'domain'};
my $msg       = "$install_dir/conf/templates/listener.msg";
my $date      = POSIX::strftime("%a, %d %b %Y %T %z", localtime);

# Build message
open(MSG, $msg) || die("Unable to open message: $!\n");
my $message = join('',<MSG>);
#close(MSG);

my $dateline = "Date: $date\n";
my $from     = "From: PacketFence <do not reply to this email!>\n";
my $subject  = "Subject: Network Access Blocked\n";
my $email    = $dateline . $from . $subject . "\n" . $message . ".\n";
my $length   = length($email);

my $kid1;
$kid1 = threads->create(\&pop3_director);

imap_director();

sub imap_director {
  my $sock = new IO::Socket::INET
  (
    LocalPort     => $imap_port,
    Proto         => 'tcp',
    Listen        => 1,
    Reuse         => 1,
  );
  if (!$sock) {
    pflogger("can't create IMAP socket: $!", 1);
    die "Can't create IMAP socket: $!\n";
  }

  $sock->autoflush(1);
  while (my $sock_handle = $sock->accept()) {
    my $client_ip = $sock_handle->peerhost();
    print "Accepting connection from $client_ip\n" if ($verbose);
    pflogger("IMAP connection from $client_ip",2);
    print $sock_handle "* OK [CAPABILITY IMAP4REV1 AUTH=LOGIN] $hostname IMAP4rev1 at $date\n";
    while ( my $request = <$sock_handle> ) {
      chomp $request;
      print "\tClient request: $request\n" if ($verbose);
      if ($request =~ /logout/i) {
        print $sock_handle "* BYE $hostname IMAP4rev1 server terminating connection\n";
        close $sock_handle;
      } elsif ($request =~ /capability/i) {
        print $sock_handle "* CAPABILITY IMAP4REV1 AUTH=LOGIN\n";
      } else {
        print $sock_handle "* OK [ALERT] $message";
        print $sock_handle "* BYE $hostname IMAP4rev1 server terminating connection\n";
        close $sock_handle;
      }
    }
  }
  close ($sock);
}

sub pop3_director {
  my $sock = new IO::Socket::INET
  (
    LocalPort     => $pop3_port,
    Proto         => 'tcp',
    Listen        => 1,
    Reuse         => 1,
  );
  die "Can't create socket: $!\n" unless $sock;

  $sock->autoflush(1);
  while (my $sock_handle = $sock->accept()) {
    my $client_ip = $sock_handle->peerhost();

    print "Accepting connection from $client_ip\n" if ($verbose);
    pflogger("POP3 connection from $client_ip",2);

    print $sock_handle "+OK POP3 $hostname server ready\n";

    while ( my $request = <$sock_handle> ) {
      chomp $request;
      print "\tClient request: $request\n" if ($verbose);
      if ($request =~ /^QUIT/i) {
        print $sock_handle "+OK I'm out!\n";
        close $sock_handle;
      } elsif ($request =~ /^STAT/i) {
        print $sock_handle "+OK 1 $length\n";
      } elsif ($request =~ /^CAPA/i) {
        print $sock_handle "+OK Capability list follows:\nUSER\n.\n";
      } elsif ($request =~ /^LIST/i) {
        print $sock_handle "+OK Mailbox scan listing follows\n1 $length\n.\n";
      } elsif ($request =~ /^(RETR|TOP)/i) {
        print $sock_handle "+OK $length octets\n";
        print $sock_handle $email;
      } elsif ($request =~ /^USER/i) {
        print $sock_handle "+OK User name accepted, password please\n";
      } elsif ($request =~ /^PASS/i) {
        print $sock_handle "+OK Mailbox open, 1 message\n";
      } elsif ($request =~ /^DELE/i) {
        print $sock_handle "+OK Message deleted\n";
      } elsif ($request =~ /^AUTH LOGIN/i) {
        my $tmp;
        print $sock_handle "+ XXXXXXXXXXXXXXXX\n";
        $tmp = <$sock_handle>;
        print $sock_handle "+ XXXXXXXXXXXXXXXX\n";
        $tmp = <$sock_handle>;
        print $sock_handle "+OK Mailbox open, 1 message\n";
      } else {
        print $sock_handle "-ERR\n";
      }
    }
  }
  close ($sock);
}

sub restart_handler {
  deletepid();
  pflogger("caught SIG".$_[0]." - restarting", 1);
  if (!exec($0, @ORIG_ARGV)) {
    pflogger("could not restart: #!", 1);
    die "pfredirect: could not restart: $!\n";
  }
}

sub normal_handler {
  deletepid();
  pflogger("caught SIG".$_[0]." - terminating", 1);
}

sub daemonize {
  createpid();
  chdir '/'               or die "Can't chdir to /: $!";
  open STDIN, '/dev/null' or die "Can't read /dev/null: $!";  
  open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";

  defined(my $pid = fork) or die "pfredirect: could not fork: $!";
  POSIX::_exit(0) if ($pid);
  if (!POSIX::setsid()) {
    pflogger("could not start a new session: $!", 1);
  }
  open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}    

sub usage {
  print STDERR << "EOF";
  Usage: $0 [OPTIONS]
        -d      Daemonize       
        -v      Verbose
        -h      Help
EOF
  exit;
}

END {
  if (!$args{h}) {
    deletepid();
    pflogger("stopping pfredirect", 1);
    $kid1->detach;                
    # kill kids...
    kill 6,-$$;
  }
}

exit(0);

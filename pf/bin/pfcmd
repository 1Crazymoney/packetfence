#!/usr/bin/perl
#
# Copyright 2005 Dave Laporte <dave@laportestyle.org>
# Copyright 2005 Kevin Amorin <kev@amorin.org>
# Copyright 2008 Inverse groupe conseil <dgehl@inverse.ca>
#
# See the enclosed file COPYING for license information (GPL).
# If you did not receive this file, see
# http://www.fsf.org/licensing/licenses/gpl.html.
#

# force UID/EUID to root to allow socket binds, etc
# required for non-root (and GUI) service restarts to work
$> = 0;
$< = 0;

use strict;
use warnings;

use Data::Dumper;
use POSIX();
use Date::Parse;
use Parse::RecDescent;
use File::Basename qw(basename);
use FindBin;
use LWP;
use CGI qw(-no_debug :standard); 
use Log::Log4perl;

use constant INSTALL_DIR => '/usr/local/pf';

use lib INSTALL_DIR . "/lib";


use pf::config;
use pf::util;
use pf::pfcmd::pfcmd;
use pf::pfcmd::pfcmd_pregrammar;
use pf::pfcmd::help;

delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

Log::Log4perl->init("$conf_dir/log.conf");
my $logger = Log::Log4perl->get_logger(basename($0));
Log::Log4perl::MDC->put('proc', basename($0));
Log::Log4perl::MDC->put('tid', 0);


if (defined($ENV{'PATH'})) {
    my @PATH = split(/:/,$ENV{'PATH'});
    my $pos = 0;
    while (($pos < scalar(@PATH)) && (! ( -x "$PATH[$pos]/getenforce" ))) {
        $pos++;
    }
    if ($pos < scalar(@PATH)) {
        my $enforcing = `$PATH[$pos]/getenforce`;
        if ($enforcing =~ /^Enforcing$/) {
            $logger->fatal("SELinux is in enforcing mode. This is currently not supported in PacketFence");
            $logger->logdie("SELinux is in enforcing mode. This is currently not supported in PacketFence");
        }
    }
}



$ENV{PATH} = "/bin:/sbin:/usr/bin:/usr/sbin";

my $count  = $ENV{PER_PAGE};
my $offset = $ENV{PAGE_NUM};

@ARGV = ($ENV{ARGS}) if ($ENV{ARGS});

if ($offset && $offset > 0) {
  $offset = $offset - 1;
  $offset = $offset * $count;
}

my %defaults;
my %myconfig;
my %documentation;

if (defined $ENV{GATEWAY_INTERFACE}){
  my $q = new CGI;
  if ($q->param("ARGS")) {
   @ARGV = $q->param("ARGS");
   print $q->header;
  } elsif (scalar(@ARGV) == 0) {
    print "ERROR in parameters";
    return(0);
  }
}

# legacy mode - allow ./start|./stop|./restart symlinks
my $called_name = basename($0);
if ($called_name =~ /^(start|stop|restart)$/i) {
  @ARGV = ("service", "pf", $called_name);
}

# generate pre-compiled grammar
#Parse::RecDescent->Precompile($grammar, "pfcmd_pregrammar");
#exit 1;

# dynamic grammar parsing (slow)
#my $parser=Parse::RecDescent->new($grammar);

# precompiled grammar (2.6x increase in speed)
my $parser=pfcmd_pregrammar->new();

my $result = $parser->start(join " ",@ARGV);
my $command = $cmd{'command'}[0];

if ($command =~ /^(help|history|ipmachistory|locationhistoryswitch|locationhistorymac|ifoctetshistorymac|ifoctetshistoryswitch|ifoctetshistoryuser|report|ui|graph|switchlocation|nodecategory)$/i) {
  ($main::{${$cmd{'command'}}[0]} or sub { print "No such sub: $_\n" })->();
  exit 1;
}

require pf::node;
import pf::node;
require pf::person;
import pf::person;
require pf::trigger;
import pf::trigger;
require pf::violation;
import pf::violation;
require pf::class;
import pf::class;
require pf::services;
import pf::services;
require pf::os;
import pf::os;
require pf::iptables;
import pf::iptables;
require pf::rawip;
import pf::rawip qw(trapmac freemac);

if ($command =~ /^(person|node|violation)$/i) {
  command_param($command);
} else {
  ($main::{${$cmd{'command'}}[0]} or sub { print "No such sub: $_\n" })->();
}
# END MAIN

sub help {
  my $service = $cmd{command}[1];
  if (!$service || !defined($main::{"help_".$service})) {
    usage();
  }else {
    ($main::{"help_".$service} or sub { print "No such sub: help_".$service."\n"; })->();
  }
}


# will be replaced in 1.6ish with SOAP
#
sub manage {
  my $option = $cmd{manage_options}[0];
  my $mac = lc($cmd{manage_options}[1]);
  my $id;
  $id = $cmd{manage_options}[2] if (defined $cmd{manage_options}[2]);
  my $function = "manage_" . $option;
  if ($option eq "freemac"){
    freemac($mac);  
  }elsif ($option eq "trapmac"){
    trapmac($mac);  
  }elsif ($option eq "register"){
    return(0) if (!$id);
    my %params=format_assignment(@{$cmd{assignment}});
    node_register($mac,$id,%params);
  }elsif ($option eq "deregister"){
    node_deregister($mac);
    if (! ($Config{'network'}{'mode'} =~ /vlan/i)) {
      iptables_generate();
    }
  }elsif ($option eq "vclose"){
    return(-1) if (!$id);
    print violation_close($mac,$id);
  }elsif ($option eq "vopen"){
    return(-1) if (!$id);
    print violation_add($mac,$id);
  }
  generate_switchport_vlan_assignment($mac,$function);
}

sub locationhistoryswitch {
  require pf::locationlog;
  import pf::locationlog;
  my $switch = $cmd{command}[1];
  my $ifIndex = $cmd{command}[2];
  my $date = str2time($cmd{command}[3]) if (defined $cmd{command}[1]);
  my %params;
  $params{'ifIndex'} = $ifIndex;
  if ($date) {
    $params{'date'} = $date;
  }
  exit(print_results("locationlog_history_switchport", $switch, %params));
}

sub locationhistorymac {
  require pf::locationlog;
  import pf::locationlog;
  my $mac = $cmd{command}[1];
  my $date = str2time($cmd{command}[2]) if (defined $cmd{command}[1]);
  my %params;
  $params{'mac'} = $mac;
  if ($date) {
    $params{'date'} = $date;
  }
  exit(print_results("locationlog_history_mac", $mac, %params));
}

sub ifoctetshistoryswitch {
  require pf::ifoctetslog;
  import pf::ifoctetslog;
  my $switch = $cmd{command}[1];
  my $ifIndex = $cmd{command}[2];
  my %params;
  $params{'ifIndex'} = $ifIndex;
  if (exists($cmd{'date_range'}) && (scalar(@{$cmd{'date_range'}}) > 0)) {
    my %date_params=format_assignment(@{$cmd{'date_range'}});
    $params{'start_time'} = str2time($date_params{'start_time'});
    $params{'end_time'} = str2time($date_params{'end_time'});
  }
  exit(print_results("ifoctetslog_history_switchport", $switch, %params));
}

sub ifoctetshistorymac {
  require pf::ifoctetslog;
  import pf::ifoctetslog;
  my $mac = $cmd{command}[1];
  my %params;
  if (exists($cmd{'date_range'}) && (scalar(@{$cmd{'date_range'}}) > 0)) {
    my %date_params=format_assignment(@{$cmd{'date_range'}});
    $params{'start_time'} = str2time($date_params{'start_time'});
    $params{'end_time'} = str2time($date_params{'end_time'});
  }
  exit(print_results("ifoctetslog_history_mac", $mac, %params));
}

sub ifoctetshistoryuser {
  require pf::ifoctetslog;
  import pf::ifoctetslog;
  my $user = $cmd{command}[1];
  my %params;
  if (exists($cmd{'date_range'}) && (scalar(@{$cmd{'date_range'}}) > 0)) {
    my %date_params=format_assignment(@{$cmd{'date_range'}});
    $params{'start_time'} = str2time($date_params{'start_time'});
    $params{'end_time'} = str2time($date_params{'end_time'});
  }
  exit(print_results("ifoctetslog_history_user", $user, %params));
}

sub nodecategory {
  require pf::nodecategory;
  import pf::nodecategory;
  my $type = $cmd{'nodecategory_options'}[0];
  my $cat = $cmd{'nodecategory_options'}[1];
  if ($type eq 'view') {
    if ($cat eq 'all') {
      exit(print_results("nodecategory_view_all"));
    } else {
      exit(print_results("nodecategory_view", $cat));
    }
  } else {
    exit(print_results("nodecategory_list", $cat));
  }
}

sub switchlocation {
  require pf::switchlocation;
  import pf::switchlocation;
  my $switch = $cmd{switchlocation_options}[1];
  my %params;
  $params{'ifIndex'} = $cmd{switchlocation_options}[2];
  exit(print_results("switchlocation_view_switchport", $switch, %params))
}

#
#  host history
#
sub history {
  require pf::iplog;
  import pf::iplog;
  my $addr = $cmd{command}[1];
  my $date = str2time($cmd{command}[2]) if (defined $cmd{command}[1]);
  my($function,%params);
  if ($addr =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
     $function="iplog_history_ip";
  } else {
     $function="iplog_history_mac";
  }
  if ($date){
    $params{'date'}=$date;
  }
  exit(print_results($function,$addr,%params));
}

sub ipmachistory {
  require pf::iplog;
  import pf::iplog;
  my $addr = $cmd{command}[1];
  my ($function,%params);
  if ($addr =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
     $function="iplog_history_ip";
  } else {
     $function="iplog_history_mac";
  }
  if (exists($cmd{'date_range'}) && (scalar(@{$cmd{'date_range'}}) > 0)) {
    my %date_params=format_assignment(@{$cmd{'date_range'}});
    $params{'start_time'} = str2time($date_params{'start_time'});
    $params{'end_time'} = str2time($date_params{'end_time'});
  }
  exit(print_results($function,$addr,%params));
}

sub traplog {
  require pf::traplog;
  import pf::traplog;
  if ($cmd{command}[1] =~ /update/) {
    traplog_update_rrd();
  } else {
    my $nb = $cmd{'traplog_options'}[1];
    my %params;
    $params{'timespan'} = $cmd{'traplog_options'}[2];
    exit(print_results('traplog_get_switches_with_most_traps',$nb,%params));
  }
  exit;
}

#
# stop/start pf services
# return service status
#
sub service {
  my $service = $cmd{command}[1];
  my $command = $cmd{command}[2];

  my @all_services=('pfdhcplistener','pfmon','pfdetect','pfredirect','snort','httpd', 'snmptrapd', 'pfsetvlan');

  if ($command =~ /^status$/i) {
    my @services;
    if ($service eq "pf") {
      @services=@all_services;
    } else {
      push(@services, $service);
    }
    my @services_which_should_be_started = service_list(@services);
    print "service|shouldBeStarted|pid\n";
    foreach my $tmp (@services){
      my $should_be_started = ((grep(/^$tmp$/,@services_which_should_be_started) > 0) ? 1 : 0);
      my $pid = service_ctl($tmp, 'status');
      print "$tmp|$should_be_started|$pid\n";
    }
    return;
  }

  if ($command =~ /^watch$/i) {
    my @services;
    if ($service eq "pf") {
      @services=@all_services;
    } else {
      push(@services, $service);
    }
    my @services_which_should_be_started = service_list(@services);
    my @incorrectly_stopped_services = ();
    foreach my $tmp (@services){
      my $should_be_started = ((grep(/^$tmp$/,@services_which_should_be_started) > 0) ? 1 : 0);
      my $pid = service_ctl($tmp, 'status');
      if (($should_be_started) && (! $pid)) {
        push @incorrectly_stopped_services, $tmp;
      }
    }
    if (scalar(@incorrectly_stopped_services) > 0) {
      print "The following processes are not running:\n" . " - " . join("\n - ", @incorrectly_stopped_services) . "\n";
      if (isenabled($Config{'servicewatch'}{'email'})) {
        my %message;
        $message{'subject'}  = "PF WATCHER ALERT";
        $message{'message'} = "The following processes are not running:\n" . " - " . join("\n - ", @incorrectly_stopped_services) . "\n";
        pfmailer(%message);
      }
      if (isenabled($Config{'servicewatch'}{'restart'})) {
        $command = 'restart';
      } else {
        return;
      }
    }
  }

  if ($command =~ /^restart$/i) {
    if ($service =~ /^pf$/i) {
      $logger->info("packetfence restart ... executing stop followed by start");
      local $cmd{command}[2] = "stop";
      service();
      local $cmd{command}[2] = "start";
      service();
      return;
    } else {
      if (! service_ctl($service, "status")) {
        $command = "start";
      }
    }
  }

  my @services;
  if ($service !~ /^pf$/) {
    push @services, $service;
  } else {
    @services = service_list(@all_services);
  }

  if ($command =~ /^start$/i) {
    sanity_check(@services);
    my $nb_running_services = 0;
    foreach my $tmp (@all_services){
      if (service_ctl($tmp, "status")) {
        $nb_running_services++;
      }
    }
    if ($nb_running_services == 0) {
      if (! ($Config{'network'}{'mode'} =~ /vlan/i)) {
        $logger->info("saving current iptables to var/iptables.bak");
        iptables_save($install_dir.'/var/iptables.bak');
      }
    }
  }

  print "service|command\n";
  if ($command !~ /^stop$/){
    print "config files|$command\n";
    read_dhcp_fingerprints_conf();
    read_violations_conf();
    if (! ($Config{'network'}{'mode'} =~ /vlan/i)) {
      print "iptables|$command\n";
      iptables_generate();
    }
  }

  foreach my $srv (@services){
    service_ctl($srv, $command);
    print "$srv|$command\n";
  }

  if ($command =~ /^stop$/i) {
    my $nb_running_services = 0;
    foreach my $tmp (@all_services){
      if (service_ctl($tmp, "status")) {
        $nb_running_services++;
      }
    }
    if ($nb_running_services == 0) {
      if (! ($Config{'network'}{'mode'} =~ /vlan/i)) {
        iptables_restore($install_dir.'/var/iptables.bak');
      }
    } else {
      if ($service =~ /^pf$/i) {
        $logger->error("even though 'control pf stop' was called, there are still $nb_running_services services running. Can't restore iptables from var/iptables.bak");
      }
    }
  }
}

sub class {
  my ($function,$id);
  $id = $cmd{class_options}[1];
  if ($id && $id!~/all/){
        $function="class_view";
  }else{
      $function="class_view_all";
  }
  exit(print_results($function,$id));
}   

#
sub trigger {
  my ($function,$id,%params);
  $id = $cmd{trigger_options}[1];
  if (defined $cmd{trigger_options}[2]){
    if ($id=~/all/){
      $id=$cmd{trigger_options}[2];
      $function="trigger_view_type";
     }else{
      $params{'type'} = $cmd{trigger_options}[2];
      $function="trigger_view";
     }
  }elsif ($id && $id!~/all/){
      $function="trigger_view_tid";
  }else{
      $function="trigger_view_all";
  }
  exit(print_results($function,$id,%params));
}  

#
sub fingerprint {
  my ($function,$id);
  $id = $cmd{fingerprint_options}[1];
  if ($id && $id!~/all/){ 
    $function="dhcp_fingerprint_view";
  }else{                
    $function="dhcp_fingerprint_view_all";
  }
  exit(print_results($function,$id));
}   

sub version {
  my($pfrelease_fh, $release);
  open($pfrelease_fh,"$conf_dir/pf-release") || $logger->logdie("Unable to open $conf_dir/pf-release: $!"); 
  $release = <$pfrelease_fh>;
  close($pfrelease_fh);
  print $release;
  
  my $md5sum = (split(/\s+/, `/usr/bin/mysqldump -n -d --host=$Config{'database'}{'host'} --port=$Config{'database'}{'port'} -n -d -u $Config{'database'}{'user'} -p'$Config{'database'}{'pass'}' $Config{'database'}{'db'} | egrep -v '(^/|^\$|^--|^DROP)'|md5sum`))[0];
  print "DB MD5SUM: $md5sum\n";
}

#
#  schedule a host scan
#
sub schedule {
  eval "use Net::Nessus::ScanLite; 1" || $logger->logdie("Net::Nessus::ScanLite not found, please install for Nessus schedule functionality");
  my $command = $cmd{command}[0];
  my $service = $cmd{command}[1] if (defined $cmd{command}[1]);
  my $option = $cmd{schedule_options}[0];
  my $hostaddr = $cmd{schedule_options}[1];
  my %params=format_assignment(@{$cmd{assignment}});

  #scan now no cron entry
  if ($option && $option=~/^now$/){
    my @output=trigger_scan($hostaddr,$params{tid});
    my $date=mysql_date();
    $date=~s/ /-/g;
    $hostaddr=~s/\//\\/g;
    open(FILE,">$install_dir/html/admin/scan/results/dump_${hostaddr}_$date");
    print FILE shift(@output)."\n";  
    print FILE join($delimiter, ("vulnerable","mac","ip","tid","sid","port","description"))."\n";
    print FILE @output;  
    #close(FILE);
    return(1); 
  }
  use pf::pfcmd::schedule;

  my $tid=$params{tid} || "all";
  my $date=$params{date} || 0;

  my $cron = new schedule();
  $cron->load_cron("pf");
  print join($delimiter, ("id","date","hosts","tid"))."\n";
  if ($option=~/^view$/){
    if ($hostaddr=~/^all$/){
      print $cron->get_indexes();
    }else {
      print join($delimiter,$cron->get_index($hostaddr))."\n";
    }
    return(1);
  }elsif ($option=~/^add$/){
     my @fields=split(/\s+/,$date); 
     if (!$date || scalar(@fields)!=5 || $date!~/^([\d\-\,\/\* ])+$/ || !$tid){
        print "Date format incorrect $date or tid incorrect $tid\n";
        $logger->error("date format incorrect");  
	return(0);
     } else{
        $cron->add_index($date,$bin_dir."/pfcmd schedule now $hostaddr tid=$tid");
     }  
  }elsif ($option=~/^delete$/){
    $cron->delete_index($hostaddr);
  }elsif ($option=~/^edit$/){
    my $id=$hostaddr;
    my ($oldate,$oldaddr,$oldtid)=($cron->get_index($id))[1,2,3];
    $hostaddr=$oldaddr;
    $hostaddr=$params{hosts} if ($params{hosts});
    $tid=$oldtid if (!$tid);
    $date=$oldate if (!$date);
    $logger->info("updating schedule number $id to date=$date,hostaddr=$hostaddr,tid=$tid");
    $cron->update_index($id,$date,$bin_dir."/pfcmd schedule now $hostaddr tid=$tid");
  }else{
    $logger->error("Schedule Failed");
    return(0);
  }

 print $cron->get_indexes();
 $cron->write_cron("pf");
}


#
#
#
sub config_entry {
  my($param, $value) = @_;
  my($default, $orig_param, $dot_param, $param2, $type, $options, $val);
  
  $orig_param = $param;
  $dot_param = $param;
  $dot_param =~ s/\s+/\./g;
  ($param, $param2) = split(" ", $param) if ($param =~ /\s/);

  if (defined($defaults{$orig_param}{$value})) {
    $default = $defaults{$orig_param}{$value};
  } else {
    $default = "";
  }
  if (defined($documentation{"$param.$value"}{'options'})) {
    $options = $documentation{"$param.$value"}{'options'};
    $options =~ s/\|/;/g;
  } else {
    $options = "";
  }
  if (defined($documentation{"$param.$value"}{'type'})) {
    $type = $documentation{"$param.$value"}{'type'};
  } else {
    $type = "text";
  }
  if (defined($myconfig{$orig_param}{$value})) {
    $val = "$dot_param.$value=$myconfig{$orig_param}{$value}";
  } else {
    $val = "$dot_param.$value=";
  }
  return join("|",$val,$default,$options,$type)."\n";
}

#
# parse pf.conf and also defaults template/pf.conf
#
sub config {
  my $option = $cmd{command}[1];
  my $param = $cmd{command}[2];
  my $value = "";

  tie %documentation, 'Config::IniFiles', ( -file => $conf_dir."/documentation.conf" ) or $logger->logdie("Unable to open documentation.conf: $!");
  tie %defaults, 'Config::IniFiles', ( -file => $conf_dir."/pf.conf.defaults" ) or $logger->logdie("Unable to open pf.conf.defaults: $!");
  tie %myconfig, 'Config::IniFiles', ( -file => $conf_dir."/pf.conf" ) or $logger->logdie("Unable to open pf.conf: $!");
  
  usage("config") if ($option =~ /^set$/i && $param !~ /^.+?=.+?$/);
  if ($option =~ /^set$/i) {
    $param =~ /^([^=]+)=(.+)$/;
    $param = $1;
    $value = $2;
  }
  # get rid of spaces (a la [interface X])
  #$param =~ s/\s+/./g;

  my $parm;
  my $section;
  
  if ($param =~ /^(interface)\.(.+)+\.([^.]+)$/) {
    $parm = $3;
    $section = "$1 $2";
  } else {
    my @stuff = split(/\./, $param);
    $parm = pop(@stuff);
    $section = join(" ",@stuff);
  }

  if ($option =~ /^get$/i) {
    if ($param =~ /^all$/) {
      foreach my $a (sort keys(%Config)) {
        foreach my $b (keys(%{$Config{$a}})) {
          print config_entry($a,$b);
        }
      }
      exit;
    }
    if (defined($Config{$section}{$parm})) {
      print config_entry($section,$parm);
    } else {
      print "Unknown configuration parameter: $param!\n";
      exit;
    }
  } elsif ($option =~ /^help$/i) {
    if (defined($documentation{$param}{'description'})) {
      print uc($param)."\n";
      print "Default: $defaults{$section}{$parm}\n" if (defined($defaults{$section}{$parm}));
      print "Options: $documentation{$param}{'options'}\n" if (defined($documentation{$param}{'options'}));
      print join("\n",@{$documentation{$param}{'description'}})."\n";
    } else {
      print "No help available for $param\n";
      exit;
    }
  } elsif ($option =~ /^set$/i) {
    if (!defined($Config{$section}{$parm})) {
      print "Unknown configuration parameter!\n";
      exit;
    } else {
      #write out the local config only - with the new value.
      if (defined($myconfig{$section}{$parm})) {
        if ((!defined($myconfig{$section}{$param})) || ($defaults{$section}{$parm} ne $value)) {
          tied(%myconfig)->setval($section,$parm,$value);
        } else {
          tied(%myconfig)->delval($section, $parm);
        }
      } elsif ($defaults{$section}{$parm} ne $value) {
        tied(%myconfig)->newval($section,$parm,$value);
      }
      tied(%myconfig)->WriteConfig($conf_dir."/pf.conf");
    }
  } else {
    print "Unknown config option!\n";
    exit;
  }
}


# 
# run reports
# 
sub report {
  require pf::pfcmd::report;
  import pf::pfcmd::report;
  my $option = $cmd{command}[0];
  my $service = $cmd{command}[1] if (defined $cmd{command}[1]);
  my $type;
  if (defined $cmd{command}[2]) {
    $type = $cmd{command}[2];
  } else {
    $type = "all"
  }
  exit(print_results("report_".$service."_".$type));
}

#
#
#
sub reload {
  my $option = $cmd{command}[1];
  if ($option eq "fingerprints") {
    my $fp_total = read_dhcp_fingerprints_conf();
    $logger->info("$fp_total DHCP fingerprints reloaded");
    print "$fp_total DHCP fingerprints reloaded\n";
  } elsif ($option eq "violations") {
    read_violations_conf();
    $logger->info("Violation classes reloaded");
    print "Violation classes reloaded\n";
  }
  exit;
}

sub update {
  my $option = $cmd{command}[1];
  my $browser = LWP::UserAgent->new;
  if ($option eq "fingerprints") {
    my $response = $browser->get($dhcp_fingerprints_url);
    if (!$response->is_success) {
      $logger->logdie("Unable to update DHCP fingerprints: ".$response->status_line);
    } else {
      my($fingerprints_fh);
      open($fingerprints_fh,">$dhcp_fingerprints_file") || $logger->logdie("Unable to open $dhcp_fingerprints_file: $!");
      my $fingerprints = $response->content;
      my ($version) = $fingerprints =~ /^#\s+dhcp_fingerprints.conf:\s+(version.+?)\n/;
      print $fingerprints_fh $fingerprints;
      close($fingerprints_fh);
      $logger->info("DHCP fingerprints updated via $dhcp_fingerprints_url to $version");
      print "DHCP fingerprints updated via $dhcp_fingerprints_url to $version\n";
      my $fp_total = read_dhcp_fingerprints_conf();
      $logger->info("$fp_total DHCP fingerprints reloaded");
      print "$fp_total DHCP fingerprints reloaded\n";
    }
  } elsif ($option eq "oui") {
    my $response = $browser->get($oui_url);
    if (!$response->is_success) {
      $logger->logdie("Unable to update OUI prefixes: ".$response->status_line);
    } else {
      my($oui_fh);
      open($oui_fh,">$oui_file") || $logger->logdie("Unable to open $oui_file: $!");
      print $oui_fh $response->content;
      close($oui_fh);
      $logger->info("OUI prefixes updated via $oui_url");
      print "OUI prefixes updated via $oui_url\n";
    }
  }
  exit;
}

sub graph {
  my $graph = $cmd{command}[1];
  if (($graph ne 'ifoctetshistoryuser') && ($graph ne 'ifoctetshistorymac') && ($graph ne 'ifoctetshistoryswitch')) {
    require pf::pfcmd::graph;
    import pf::pfcmd::graph;
    my $interval;
    if (defined $cmd{command}[2]) {
      $interval = $cmd{command}[2];
    } else {
      $interval = "day";
    }
    exit(print_graph_results("graph_".$graph, $interval));
  } else {
    require pf::ifoctetslog;
    import pf::ifoctetslog;
    my %params;
    my %date_params=format_assignment(@{$cmd{'date_range'}});
    $params{'start_time'} = str2time($date_params{'start_time'});
    $params{'end_time'} = str2time($date_params{'end_time'});
    my @results;
    if ($graph eq 'ifoctetshistoryuser') {
      @results=ifoctetslog_graph_user($cmd{command}[2], %params);
    } elsif ($graph eq 'ifoctetshistorymac') {
      @results=ifoctetslog_graph_mac($cmd{command}[2], %params);
    } elsif ($graph eq 'ifoctetshistoryswitch') {
      $params{'ifIndex'} = $cmd{command}[3];
      @results=ifoctetslog_graph_switchport($cmd{command}[2], %params);
    }
    print "count|mydate|series\n";
    foreach my $set (@results) {
      print $set->{'throughPutIn'} . "|" . $set->{'mydate'} . "|in\n";
      print $set->{'throughPutOut'} . "|" . $set->{'mydate'} . "|out\n";
    }
  }
}

sub lookup {
  my $option = $cmd{command}[0];
  my $service = $cmd{command}[1];
  my $id = $cmd{command}[2];

  # this file contains the pidlookup function
  # that can be customized to your environment
  push @INC, $bin_dir;
  require "$bin_dir/lookup_".$service.".pl";

  my $function = "lookup_".$service;
  my $tmp_lookup = ($main::{$function} or sub { print "No such sub: $function\n" })->($id);
  print $tmp_lookup;
}

#
# parse ui.conf config file
#
sub ui {
  my ($type) = @_;
  my $service = $cmd{command}[1];
  my $option = $cmd{command}[2];
  my $interval = $cmd{command}[3];

  if ($service eq "menus") {
    # check if Net::Nessus::ScanLite is installed
    my $scanLiteInstalled = 1;
    eval "use Net::Nessus::ScanLite";
    if ($@) {
      $scanLiteInstalled = 0;
    }
    # read in configuration file
    my %uiconfig;
    my $ui_conf_file = $conf_dir."/ui.conf";
    if (defined($cmd{'ui_options'})) {
      $ui_conf_file= $conf_dir."/" . $cmd{'ui_options'}[2];
    }
    tie %uiconfig, 'Config::IniFiles', ( -file => $ui_conf_file ) or $logger->logdie("Unable to open $ui_conf_file: $!");

    my $string;  
    foreach my $section (tied(%uiconfig)->Sections) {
      my @array = split(/\./,$section);
      my $service = $array[1] if ($array[1]);
      next if ((defined $service) && ($service eq "scan") && (! $scanLiteInstalled));
      $string .= join("|", @array)."|";
      my @keys;
      #print "NO SECTION $section \n" if (!defined $uiconfig{$section}{'display'});
      foreach my $key (split(/\s*,\s*/,$uiconfig{$section}{'display'})) {
        my $key2;   
        if (defined $service && defined($table2key{$service}) && $table2key{$service} eq $key) {
          $key2 = $key."*";
        } else {
          $key2 = $key;
        }               
        $key=~s/^-//;
        next if (($key eq "scan") && (! $scanLiteInstalled));
        if (defined $uiconfig{$section}{$key}){
          push @keys, "$key2='$uiconfig{$section}{$key}'";
        }else{
          #print "NO SECTION $section $key \n" if (!defined $uiconfig{$section}{$key});
          push @keys, "$key2='$key2'";
        }
      }
      $string .= join(":", @keys)."\n";
    }
    print $string;
  } elsif ($service eq "dashboard") {
    require pf::pfcmd::dashboard;
    import pf::pfcmd::dashboard;
    $interval = 3 unless ($interval);
    exit(print_results("nugget_".$option, $interval));
  } else {
    usage("help");
  }
}

#
# node,person,violation parser
#
sub command_param {
  my ($type) = @_;
  my $options = $type."_options";
  my $option = $cmd{$options}[0];
  my $id = $cmd{$options}[1];
  # strip out the delimiter
  $id =~ s/$delimiter//g;
  my $function=$type;
  if ($option eq "view") {
    $function.="_view";
    $function.="_all" if ($id=~/^all/);
    if (defined($cmd{'node_filter'})) {
      $function.="_with_filter";
      $id=$cmd{'node_filter'}[2];
    }
    exit(print_results($function,$id));
    return(0);
  } elsif ($option eq "add"){
    $function.="_add"; 
  } elsif ($option eq "edit") {
    $function.="_modify";       
  } elsif ($option eq "delete") {
    $function.="_delete"; 
  } else {
    usage("param");
  }

  my $assignment = $type."_assignment";
  my %params=format_assignment(@{$cmd{$assignment}});
  my $returnValue = 0;
  if (($function eq "node_modify") || ($function eq "node_add")) {
    $id = lc($id);
  }
  #print Dumper(%params);
  # run update/or delete  and check return val
  if ($function eq "violation_add"){
    $logger->info("pfcmd calling $function for " . $params{mac});
    ($main::{$function} or sub { print "No such sub: $_\n" })->($params{mac},$params{vid},%params);
  }else {
    if ($function eq "violation_delete") {
      my @violation_data = violation_view($id);
      if (scalar(@violation_data) == 1) {
        $params{mac} = $violation_data[0]->{'mac'};
      } else {
        $params{mac} = '';
      }
    }
    $logger->info("pfcmd calling $function for $id");
    $returnValue = ($main::{$function} or sub { print "No such sub: $_\n" })->($id,%params);
  }
  if ($returnValue != 2) {
    #print "$function updated\n";
    if ($function =~ /^person_add|person_modify$/) {
      $logger->debug("$function was called - we don't need to recalculate iptables and switchport VLAN assignments");
    } else {
      if (! ($Config{'network'}{'mode'} =~ /vlan/i)) {
        iptables_generate();
      }
      if ($function =~ /^violation/) {
        generate_switchport_vlan_assignment($params{mac},$function);
      } else {
        generate_switchport_vlan_assignment($id,$function);
      }
    }
    return(0);
  } else {
    print "error: please consult log for more information\n";
    return(2);
  }
}

#
# given a function name and a table will execute the function and correctly format the output
# example: print_results("node","node_view_all");
#
sub print_results {
  my ($function,$key,%params)=@_;
  my $total;
  my @results=($main::{$function} or sub { print "No such sub $function: $_\n"; })->($key,%params);
  $total = scalar(@results);
  if ($count) {
    $offset = scalar(@results) if ($offset > scalar(@results));
    $count = scalar(@results) - $offset if ($offset  + $count > scalar(@results));
    @results = splice(@results, $offset, $count);
  }

  my @fields=field_order();
  push @fields, keys(%{$results[0]}) if (!scalar(@fields));   

  if (scalar(@fields)) {
    print join($delimiter, @fields)."\n";
    foreach my $row (@results) {
      next if (defined($row->{'mydate'}) && $row->{'mydate'} =~ /^00/);
      my @values = ();
      foreach my $field (@fields) {
        my $value = $row->{$field};
        if (defined($value) && $value!~/^0000-00-00 00:00:00$/) {
          # little hack to reverse dates
          if ($value =~ /^(\d+)\/(\d+)$/) {
            $value = "$2/$1";
          } elsif ($value =~ /^(\d+)\/(\d+)\/(\d+)$/) {
             $value = "$2/$3/$1";
          }
          push @values, $value;
        } else {
          push @values, "";
        }
      }
      print join($delimiter,@values)."\n";
    }
  }
  return($total);
}

# This function has dirtied my soul.  I beg forgiveness for the disgusting code that follows.
# I need a brillo pad and a long, long shower...

sub print_graph_results {
  my ($function,$interval) = @_;

  # TOTAL HACK, but we avoid using yet another module
  my %months = ( "01" => "31",
                 "02" => "28",
                 "03" => "31",
                 "04" => "30",
                 "05" => "31",
                 "06" => "30",
                 "07" => "31",
                 "08" => "31",
                 "09" => "30",
                 "10" => "31",
                 "11" => "30",
                 "12" => "31"
               );

  my @results=($main::{$function} or sub { print "No such sub $function: $_\n"; })->($interval);
  my %series;
  foreach my $result (@results) {
    next if ($result->{'mydate'} =~ /0000/);
    my $s = $result->{'series'};
    push(@{$series{$s}}, $result);
  }
  my @fields=field_order();
  push @fields, keys(%{$results[0]}) if (!scalar(@fields));
  print join("|", @fields)."\n";
  foreach my $s (keys(%series)) {
    my @results = @{$series{$s}};
    my $year = POSIX::strftime("%Y", localtime);
    my $month = POSIX::strftime("%m", localtime);
    my $day = POSIX::strftime("%d", localtime);
    my $date;
    if ($interval eq "day") {
      $date = "$year/$month/$day";
    } elsif ($interval eq "month") {
      $date = "$year/$month";
    } elsif ($interval eq "year") {
      $date = "$year";
    } else {
    }
    if ($results[scalar(@results)-1]->{'mydate'} ne $date) {
      my %tmp = %{$results[scalar(@results)-1]};
      $tmp{'mydate'} = $date;
      push(@results, \%tmp);
    }
    push(@results, $results[0]) if (scalar(@results) == 1);
    if ($interval eq "day") {
      for (my $r = 0; $r < scalar(@results)-1; $r++) {
        my ($start_year, $start_mon, $start_day) = split (/\//, $results[$r]->{'mydate'});
        my ($end_year, $end_mon, $end_day) = split(/\//, $results[$r+1]->{'mydate'});
        my $mstart = $start_mon;
        my $dstart = $start_day;
        for (my $i = $start_year; $i <= $end_year; $i++) {
          my $mend;
          if ($i == $end_year) {
            $mend = $end_mon;
          } else {
            $mend = "12";
          }
          for (my $ii = $mstart; $ii <= $mend; $ii++) {
            my $dend;
            if ($i == $end_year && $ii == $end_mon) {
              $dend = $end_day;
            } else {
              $dend = $months{sprintf("%02d",$ii)};
            }
            for (my $iii = $dstart; $iii <= $dend; $iii++) {
              if (!($i == $end_year && $ii == $end_mon && $iii == $end_day)) {
                my @values;
                foreach my $field (@fields) {
                  if ($field eq "mydate") {
                    push(@values, join("/", sprintf("%02d",$ii), sprintf("%02d",$iii), sprintf("%02d",$i)));
                  } else {
                    push(@values, $results[$r]->{$field});
                  }
                }
                print join("|",@values)."\n";
              }
            }
            $dstart = 1;
          }
        }
        $mstart = 1;
      }
      my ($year, $mon, $day) = split (/\//, $results[scalar(@results)-1]->{'mydate'});
      my @values;
      foreach my $field (@fields) {
        if ($field eq "mydate") {
          push(@values, join("/", sprintf("%02d", $mon), sprintf("%02d", $day), sprintf("%02d",$year)));
        } else {
          push(@values, $results[scalar(@results)-1]->{$field});
       }                 
     }      
     print join("|",@values)."\n";


    } elsif ($interval eq "month") {
      for (my $r = 0; $r < scalar(@results)-1; $r++) {
        my ($start_year, $start_mon) = split (/\//, $results[$r]->{'mydate'});
        my ($end_year, $end_mon) = split(/\//, $results[$r+1]->{'mydate'});
        my $mstart = $start_mon;
        for (my $i = $start_year; $i <= $end_year; $i++) {
          my $mend;
          if ($i == $end_year) {
            $mend = $end_mon;
          } else {
            $mend = "12";
          }
          for (my $ii = $mstart; $ii <= $mend; $ii++) {
            if (!($i == $end_year && $ii == $end_mon)) {
              my @values;
              foreach my $field (@fields) {
                if ($field eq "mydate") {
                  push(@values, join("/", sprintf("%02d",$ii), sprintf("%02d",$i)));
                } else {
                  push(@values, $results[$r]->{$field});
                }
              }
              print join("|",@values)."\n";
            }
          }
          $mstart = 1;
        }
      }
      my ($year, $mon) = split (/\//, $results[scalar(@results)-1]->{'mydate'});
      my @values;
      foreach my $field (@fields) {
        if ($field eq "mydate") {
          push(@values, join("/", sprintf("%02d", $mon), sprintf("%02d",$year)));
        } else {
          push(@values, $results[scalar(@results)-1]->{$field});
       }                 
     }      
     print join("|",@values)."\n";
    } elsif ($interval eq "year") {
      for (my $r = 0; $r < scalar(@results)-1; $r++) {
        my ($start_year) = $results[$r]->{'mydate'};
        my ($end_year) = $results[$r+1]->{'mydate'};
        for (my $i = $start_year; $i <= $end_year; $i++) {
          if (!($i == $end_year)) {
            my @values;
            foreach my $field (@fields) {
              if ($field eq "mydate") {
                push(@values, sprintf("%02d",$i));
              } else {
                push(@values, $results[$r]->{$field});
              }
            }
            print join("|",@values)."\n";
          }
        }
      }
      my ($year) = $results[scalar(@results)-1]->{'mydate'};
      my @values;
      foreach my $field (@fields) {
        if ($field eq "mydate") {
          push(@values, sprintf("%02d", $year));
        } else {
          push(@values, $results[scalar(@results)-1]->{$field});
       }                 
     }      
     print join("|",@values)."\n";
    }
  }
}

#
# format a hash of assignments based on the grammar
# example: format_assignment($cmd{node_assignment); 
#
sub format_assignment {
  my @fields=@_;
  my (@columns, @values, @assignment, %return);
  foreach my $array (@fields){
    my $column = $array->[0];
    my $value = $array->[1];
    my $assignment=$array->[2];
    $column =~ s/$delimiter//g;
    $value =~ s/$delimiter//g;
    $return{$column}=$value;
  }
  return(%return);
}


# return the correct field order listed in ui.conf Display
#
sub field_order {
  my %uiconfig;
  tie %uiconfig, 'Config::IniFiles', ( -file => $conf_dir."/ui.conf" ) or $logger->logdie("Unable to open ui.conf: $!");
  my @fields;
  foreach my $section (sort tied(%uiconfig)->Sections) {
    if (defined $uiconfig{$section}{'command'}  && join(" ",@ARGV)=~/^$uiconfig{$section}{'command'}/){
      foreach my $val (split(/\s*,\s*/,$uiconfig{$section}{'display'})){
        $val=~s/-//;
        push @fields, $val;
      }
      last;
    }
  }
  untie %uiconfig;
  return (@fields);
}

sub sanity_check {
  my (@services) = @_;

  foreach my $service (@services){
    my $exe = ($Config{'services'}{$service} || "$install_dir/sbin/$service");
   $logger->logdie("$exe for $service does not exist !") if (!-e $exe);
  }
  
  my %seen;
  print "Checking configuration sanity...\n";

  # make sure the services we start are not already running
  foreach my $service (@_) {
    $logger->logdie("$service is already running!") if (`pidof -s -x $service` =~ /^\d/);
  }

  #check the config file to make sure interfaces are fully defined 
  foreach my $interface (tied(%Config)->GroupMembers("interface")) {
    if ($Config{$interface}{'type'} !~ /monitor|dhcplistener/){
      if (!defined $Config{$interface}{'ip'} || !defined $Config{$interface}{'mask'} ||!defined $Config{$interface}{'gateway'}){
          $logger->logdie("incomplete network information for $interface ");
      }
    }
  }

  # check the Netmask objs and make sure a managed and internal interface exist 
  my @tmp_nets;
  push @tmp_nets, @internal_nets;
  push @tmp_nets, @managed_nets;
  if (!scalar(@internal_nets)) {
    $logger->logdie("internal network(s) not defined!");
  }
  if (scalar(@managed_nets) != 1) {
    $logger->logdie("please define exactly one managed interace");
  }
  foreach my $interface (@tmp_nets) {
    my $device = "interface ".$interface->tag("int");
    if (!($Config{$device}{'mask'} && $Config{$device}{'ip'} && $Config{$device}{'gateway'} && $Config{$device}{'type'}) && !$seen{$interface}) {
      $logger->logdie("incomplete network information for $device");
    }
    $seen{$interface} = 1;
  }


  if (isenabled($Config{'trapping'}{'detection'})) {
    # make sure a monitor device is present if snort is enabled
    if (!$monitor_int) {
      $logger->logdie("monitor interface not defined, please disable trapping.dectection or set an interface type=...,monitor in pf.conf");
    }

    # make sure named pipe 'alert' is present if snort is enabled
    my $snortpipe = "$install_dir/var/alert";
    if (! -p $snortpipe) {
      if (! POSIX::mkfifo($snortpipe, 0666)) {
        $logger->logdie("snort alert pipe ($snortpipe) does not exist and unable to create it");
      }
    }
  }
  
  if (isenabled($Config{'trapping'}{'detection'})) {
    if (! -x $Config{'services'}{'snort'}) {
        $logger->logdie("snort binary is not executable / does not exist!");
    }
  }

  # make sure trapping.passthrough=proxy if
  # network.mode is set to vlan
  if ($Config{'network'}{'mode'} eq 'vlan') {
    if ($Config{'trapping'}{'passthrough'} eq 'iptables') {
      $logger->logdie("Please set trapping.passthrough to proxy while using VLAN isolation mode");
    }
  }

  # make sure dhcp information is complete and valid 
  # (if network.mode is set to dhcp)
  if ($Config{'network'}{'mode'} eq 'dhcp') {
    my @dhcp_scopes;
    foreach my $dhcp (tied(%Config)->GroupMembers("dhcp")) {
      if (defined($Config{$dhcp}{'registered_scopes'})) {
        @dhcp_scopes = split(/\s*,\s*/, $Config{$dhcp}{'registered_scopes'});
      }
      if (defined($Config{$dhcp}{'unregistered_scopes'})) {
        push @dhcp_scopes, split(/\s+/, $Config{$dhcp}{'unregistered_scopes'});
      }
      if (defined($Config{$dhcp}{'isolation_scopes'})) {
        push @dhcp_scopes, split(/\s+/, $Config{$dhcp}{'isolation_scopes'});
      }
    }

    if (scalar(@dhcp_scopes) == 0) {
      $logger->logdie("missing dhcp scope information");
    }

    foreach my $scope (@dhcp_scopes) {
      if (!defined $Config{'scope '.$scope}{'network'} || !defined $Config{'scope '.$scope}{'gateway'} ||!defined $Config{'scope ' .$scope}{'range'}){
          $logger->logdie("incomplete dhcp scope information for $scope ");
      }

      my $found = 0;
      foreach my $int (@internal_nets) {
        if ($Config{'interface '.$int->tag('int')}{'ip'} eq $Config{'scope '.$scope}{'gateway'}) {
          $found = 1;
          next;
        }
      }
      if (! $found) {
        $logger->logdie("dhcp scope $scope gateway ($Config{'scope '.$scope}{'gateway'}) is not bound to internal interface ","WARNING");
      }
    }
    if (!-e "$conf_dir/registered.mac"){
		open FILE, ">>$conf_dir/registered.mac";
		print FILE "#autogenerated";
		close FILE;
	}
    if (!-e "$conf_dir/isolated.mac"){
		open FILE, ">>$conf_dir/isolated.mac";
		print FILE "#autogenerated";
		close FILE;
	}
  }

  # network size warning
  my $internal_total;
  foreach my $internal_net (@internal_nets) {
    if ($internal_net->bits() < 22) {
      $logger->logwarn("network $internal_net is larger than a /22 - you may want to consider registration queueing!");
    }
    if ($internal_net->bits() < 16 && isenabled($Config{'general'}{'caching'})) {
      $logger->logdie("network $internal_net is larger than a /16 - you must disable general.caching!");
    }
    $internal_total += $internal_net->size();
  }
  if ($internal_total >= 1536) {
    $logger->logwarn("internal IP space is very large - you may want to consider registration queueing!");
  }

  # stuffing warning
  if (isenabled($Config{'arp'}{'stuffing'})) {
    $logger->logwarn("ARP stuffing is enabled...this is dangerous!");
  }

  # make sure pid 1 exists
  if (!person_exist(1)){
    $logger->logdie("person user id 1 must exist - please reinitialize your database"); 
  }   

  # make sure admin port exists
  if (!$Config{'ports'}{'admin'}){
    $logger->logdie("please set the web admin port in pf.conf (ports.admin)");
  }

  # make sure dns servers exist
  if (!$Config{'general'}{'dnsservers'}){
    $logger->logdie("please set the dns servers list in pf.conf (general.dnsservers).  If this is not set users in isolation will not be able to resolve hostnames, and will not able to reach PacketFence!");
  }

  # warn when scan.registration=enabled and trapping.registration=disabled
  if (isenabled($Config{'scan'}{'registration'}) && isdisabled($Config{'trapping'}{'registration'})) {
    $logger->logwarn("scan.registration is enabled but trapping.registration is not ... this is strang!");
  }


  if ($Config{'registration'}{'skip_mode'} eq "deadline" && !$Config{'registration'}{'skip_deadline'}) {
    $logger->logdie("pf.conf value registration.skip_deadline is mal-formed or null! (format should be that of the 'date' command)");
  } elsif ($Config{'registration'}{'skip_mode'} eq "windows" && !$Config{'registration'}{'skip_window'}) {
    $logger->logdie("pf.conf value registration.skip_window is not defined!");
  }

  if ($Config{'registration'}{'expire_mode'} eq "deadline" && !$Config{'registration'}{'expire_deadline'}) {
    $logger->logdie("pf.conf value registration.expire_deadline is mal-formed or null! (format should be that of the 'date' command)");
  } elsif ($Config{'registration'}{'expire_mode'} eq "window" && !$Config{'registration'}{'expire_window'}) {
    $logger->logdie("pf.conf value registration.expire_window is not defined!");
  }

  tie %myconfig, 'Config::IniFiles', ( -file => $config_file, -import => Config::IniFiles->new( -file => $default_config_file ) );
  tie %documentation, 'Config::IniFiles', ( -file => $conf_dir."/documentation.conf" );
  my @errors = @Config::IniFiles::errors;
  if (scalar(@errors)) {
    print STDERR join("\n",@errors)."\n";
    exit;
  }

  foreach my $section (sort tied(%documentation)->Sections) {
    my($group,$item) = split(/\./, $section);
    my $type = $documentation{$section}{'type'};
    next if ($section =~ /^(proxies|passthroughs)$/ || $group =~ /^(dhcp|scope|interface|routedsubnet|services)$/);
    next if (($group eq 'alerting') && ($item eq 'fromaddr'));
    next if (($group eq 'arp') && ($item eq 'listendevice'));
    if (defined($Config{$group}{$item})) {
      if ($type eq "toggle") {
        if ($Config{$group}{$item} !~ /^$documentation{$section}{'options'}$/) {
          $logger->logdie("pf.conf value $group\.$item must be one of the following: ".$documentation{$section}{'options'});
        }
      } elsif ($type eq "time") {
        if ($myconfig{$group}{$item} !~ /\d+[smhdw]$/) {
	  $logger->logdie("pf.conf value $group\.$item does not explicity define interval (eg. 7200s, 120m, 2h) - please define it before running packetfence");
        }
      }
    } elsif ($Config{$group}{$item} ne "0") {
      $logger->logdie("pf.conf value $group\.$item is not defined!");
    }
  }
}

sub generate_switchport_vlan_assignment {
  my ($mac,$function) = @_;
  if (($Config{'network'}{'mode'} =~ /vlan/i) && grep(/^$function$/,split(/\s*,\s*/,$Config{'vlan'}{'adjustswitchportvlanreasons'})) > 0) {
    $logger->info("VLAN isolation is enabled and $function is part of adjustswitchportvlanreasons");
    require pf::locationlog;
    import pf::locationlog;
    my $locationlog_entry = locationlog_view_open_mac($mac);
    if ($locationlog_entry) {
      require pf::vlan;
      import pf::vlan;
      my $switch_ip = $locationlog_entry->{'switch'};
      my $ifIndex = $locationlog_entry->{'port'};
      my $currentVlan = $locationlog_entry->{'vlan'};
      $logger->info("$mac is currentlog connected at $switch_ip ifIndex $ifIndex in VLAN $currentVlan");
      my $newCorrectVlan = vlan_determine_for_node($mac,$switch_ip,$ifIndex);
      $logger->info("new correct VLAN for $mac is $newCorrectVlan");
      if (($currentVlan eq 'WIFI') || ($newCorrectVlan ne $currentVlan)) {
        $logger->info("calling " . $Config{'vlan'}{'adjustswitchportvlanscript'} . " for node $mac (current VLAN = $currentVlan but should be in VLAN $newCorrectVlan)");
        my @args = ($Config{'vlan'}{'adjustswitchportvlanscript'}, $mac);
        system(@args);
      }
    } else {
      $logger->warn("no open locationlog entry for $mac");
    }
  }
}

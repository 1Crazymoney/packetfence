#!/usr/bin/perl

use strict;
use warnings;

use lib '/usr/local/pf/lib';

use pf::services::util;
use POSIX qw(:signal_h pause :sys_wait_h setuid setgid);
use pf::log;
use pf::cluster;
use pf::config qw(
    %Config
);
use pf::util;
use DBI;
use pf::constants;
use JSON::MaybeXS;
use pf::CHI;
use List::MoreUtils qw(any);

our $PROGRAM_NAME = $0 = "pf-mariadb";

my $logger = get_logger( $PROGRAM_NAME );
my $gvwstate_cache = pf::CHI->new(namespace => "gvwstate_quorum");

our $RUNNING = 1;

our $MYSQLD_SPAWNER_PID;
our $QUORUM_MGMT_SERVER_PID;
our $QUORUM_CLIENT_SERVER_PID;
our $IS_CHILD;

# How many times should we attempt to connect to a galera cluster when an alive quorum is there
# After this, the management node will declare a new cluster if its not in maintenance mode
# TODO: move this to configuration
our $PEERS_ALIVE_CONNECT_ATTEMPT = 1;

# Time to wait between starts after a failure
# TODO: move this to configuration
our $WAIT_TIME_FAIL = 10;

# Time to wait between attempts to discover alive servers
# TODO: move this to configuration
our $WAIT_TIME_ALIVE = 10;

our $failed_counts = {};

# init signal handlers
my $old_child_sigaction = POSIX::SigAction->new;
POSIX::sigaction(
    &POSIX::SIGCHLD,
    POSIX::SigAction->new(
        'child_sighandler' , POSIX::SigSet->new(), &POSIX::SA_NODEFER
    ),
    $old_child_sigaction
) or die("pf-mariadb could not set SIGCHLD handler: $!");

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or $logger->logdie("pf-mariadb: could not set SIGTERM handler: $!");

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or $logger->logdie("pf-mariadb: could not set SIGINT handler: $!");


my $STARTED_BECAUSE;

=head2 record_started_because

Increment a counter for a starting strategy

=cut

sub record_started_because {
    my ($started_because) = @_;
    if(!$started_because) {
        die "Missing starting reason";
    }

    $STARTED_BECAUSE = $started_because;

}

=head2 launch_mysql

Launch MySQL/MariaDB with a specific set of arguments

=cut

sub launch_mysql {
    my ($exec, @args) = @_;
    $exec //= 1;
    
    my $args = join(' ', @ARGV, @args);
    # Must not lookup in /sbin for mysqld, but in /usr/sbin
    $ENV{PATH} = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin";
    my $cmd = "mysqld_safe --defaults-file=/usr/local/pf/var/conf/mariadb.conf $args";
    print "Starting MySQL with command: $cmd \n";
    if($exec) {
        exec($cmd);
    } else {
        `$cmd`;
    }
}

=head2 fork_launch_mysql

Fork and start MySQL/MariaDB
Also record the startup method for future usage

=cut

sub fork_launch_mysql {
    my ($started_because, @args) = @_;
    my $pid = fork();

    record_started_because($started_because);

    if($pid) {
        $MYSQLD_SPAWNER_PID = $pid;
    } elsif ($pid == 0) {
        POSIX::sigaction(
            &POSIX::SIGCHLD,
            $old_child_sigaction,
        ) or die("pf-mariadb could not set SIGCHLD handler: $!");

        my (undef, undef,$uid,$gid) = getpwnam('mysql');
        setuid($uid);
        setgid($gid);

        $SIG{CHLD} = "DEFAULT";
        $IS_CHILD = 1;
        $0 = "pf-mariadb - mysqld spawner";
        launch_mysql($TRUE, @args);
        $RUNNING = 0;
        exit;
    }
}

=head2 ping_quorum

Whether or not there is a ping quorum (i.e. servers are booted and online)

=cut

sub ping_quorum {
    my $alive = 0;
    foreach my $server (@cluster_servers) {
        if(ping($server->{management_ip})) {
            $alive ++;
        }
    }
    return ($alive > (scalar(@cluster_servers) / 2));
}

=head2 test_db

Test the connection to the database for a specific host using the replication credentials

=cut

sub test_db {
    my ($host) = @_;
    my $mydbh = DBI->connect( "dbi:mysql:dbname=mysql;host=$host;port=3306",
        $Config{active_active}{galera_replication_username}, $Config{active_active}{galera_replication_password}, { RaiseError => 0, PrintError => 0, mysql_auto_reconnect => 1 } );

    # make sure we have a database handle
    if ($mydbh) {
        return 1;
    }
    else {
        return 0;
    }
}

=head2 db_available

One of the cluster members has its database running.

=cut

sub db_available {
    my $alive = 0;

    foreach my $server (@cluster_servers) {
        my $host = $server->{management_ip};
        $alive ++ if(test_db($host));
    }
    return ($alive > 0);
}

=head2 get_failed_count

Get the count of fails for a specific startup method

=cut

sub get_failed_count {
    return $failed_counts->{$_[0]} // 0;
}

sub quorum_management_server {
    my $pid = fork();

    if($pid) {
        $QUORUM_MGMT_SERVER_PID = $pid;
    } elsif ($pid == 0) {
        POSIX::sigaction(
            &POSIX::SIGCHLD,
            $old_child_sigaction,
        ) or die("pf-mariadb could not set SIGCHLD handler: $!");

        $SIG{CHLD} = "DEFAULT";
        $IS_CHILD = 1;
        $0 = "pf-mariadb - quorum management server";

        my $socket = new IO::Socket::INET (
            LocalHost => '0.0.0.0',
            LocalPort => '7890',
            Proto => 'tcp',
            Listen => 5,
            Reuse => 1
        );
        die "cannot create socket $!\n" unless $socket;

        while($RUNNING) {
            my $client_socket = $socket->accept();
            next unless($client_socket);
            # Receive up to 2048 bytes
            # Payload should be a JSON value representing this:
            # TODO: encrypt this with the active_active.password as a shared key
            # {
            #   "server_mgmt_ip": "1.2.3.4",
            #   "gvwstate_timestamp": 123456789,
            #   "gvwstate_uuid": "uuid1",
            #   "gvwstate_members": [
            #     "uuid1",
            #     "uuid2",
            #     ...
            #   ]
            # }
            eval {
                my $payload = "";
                $client_socket->recv($payload, 2048);

                my $data = decode_json($payload);
                $gvwstate_cache->set("gvwstate-".$data->{server_mgmt_ip}, $data);

                shutdown($client_socket, 1);
            };
            if($@) {
                my $msg = "Error while receiving on quorum socket: $@";
                print STDERR $msg;
                $logger->error($msg);
            }
        }
        # We've done our job if we're here, so we can safely exit
        exit;
    }
}

sub quorum_client_server {

    my $pid = fork();

    if($pid) {
        $QUORUM_CLIENT_SERVER_PID = $pid;
    } elsif ($pid == 0) {
        POSIX::sigaction(
            &POSIX::SIGCHLD,
            $old_child_sigaction,
        ) or die("pf-mariadb could not set SIGCHLD handler: $!");

        $SIG{CHLD} = "DEFAULT";
        $IS_CHILD = 1;
        $0 = "pf-mariadb - quorum client server";

        my $socket = new IO::Socket::INET (
            LocalHost => '0.0.0.0',
            LocalPort => '7891',
            Proto => 'tcp',
            Listen => 5,
            Reuse => 1
        );
        die "cannot create socket $!\n" unless $socket;

        while($RUNNING) {
            my $client_socket = $socket->accept();
            next unless($client_socket);
            # Receive up to 2048 bytes
            # Payload should be a JSON value representing this:
            # TODO: encrypt this with the active_active.password as a shared key
            # {
            #   "should_start": [1|0],
            # }
            eval {
                my $payload = "";
                $client_socket->recv($payload, 2048);

                my $data = decode_json($payload);
                $gvwstate_cache->set("gvwstate-should-start", $data->{should_start});

                shutdown($client_socket, 1);
            };
            if($@) {
                my $msg = "Error while receiving on quorum client socket: $@";
                print STDERR $msg;
                $logger->error($msg);
            }
        }
        # We've done our job if we're here, so we can safely exit
        exit;
    }
}

sub send_to_quorum_client {
    my ($ip, $data) = @_;
    eval {
        my $socket = new IO::Socket::INET (
            PeerHost => $ip,
            PeerPort => '7891',
            Proto => 'tcp',
        );
        die "cannot connect to the server $!\n" unless $socket;

        $socket->send(encode_json($data));
    };
    if($@) {
        my $msg = "Cannot send message to quorum client $ip: $@";
        $logger->error($msg);
        print STDERR $msg;
    }
}

sub send_info_to_quorum_server {
    eval {
        my $gvwstate = "/var/lib/mysql/gvwstate.dat";
        my $myuuid = "unknown";
        my $members = [];
        my $timestamp = 0;
        if(-f $gvwstate) {
            $myuuid = `cat $gvwstate | grep my_uuid | awk '{print \$2}'`;
            $myuuid =~ s/\n//g;
            $members = [ split("\n", `cat $gvwstate | grep member | awk '{print \$2}'`) ];
            $timestamp = ( stat($gvwstate) )[9];
        }
        my $socket = new IO::Socket::INET (
            PeerHost => $cluster_servers[0]->{management_ip},
            PeerPort => '7890',
            Proto => 'tcp',
        );
        die "cannot connect to the server $!\n" unless $socket;

        $socket->send(encode_json({
            server_mgmt_ip => pf::cluster::current_server->{management_ip},
            gvwstate_timestamp => $timestamp,
            gvwstate_uuid => $myuuid,
            gvwstate_members => $members,
        }));
    };
    if($@) {
        my $msg = "Cannot send state to master server: $@";
        $logger->error($msg);
        print STDERR $msg;
    }
}

sub get_gvwstate_info {
    my $info = {};
    for my $server (@cluster_servers) {
        my $server_info = $gvwstate_cache->get("gvwstate-".$server->{management_ip});
        $info->{$server->{host}} = $server_info if(defined($server_info));
    }
    return $info;
}

sub startup_clean_shutdown {
    if(db_available()) {
        $logger->info("There is a peer with an alive DB. Will attempt to connect to the cluster");
        fork_launch_mysql("db-peer-available");
    }
    elsif(ping_quorum()) {
        $logger->info("There is an alive quorum but no db available on any server");
        if(get_failed_count("peers-alive-no-db") < $PEERS_ALIVE_CONNECT_ATTEMPT) {
            $logger->info("Trying to connect to peers to establish an eventual quorum");
            sleep $WAIT_TIME_FAIL;
            fork_launch_mysql("peers-alive-no-db");
        }
        else {
            if(pf::cluster::cluster_index() == 0) {
                $logger->info("Tried connecting to peers too many times. Will establish a new cluster");
                `sed -i.bak "s/safe_to_bootstrap: 0/safe_to_bootstrap: 1/g" /var/lib/mysql/grastate.dat`;
                launch_mysql($FALSE, "--wsrep-recover");
                fork_launch_mysql("create-new-cluster", "--wsrep-new-cluster");
            }
            else {
                $logger->info("Tried connecting to peers too many times. Will flush state and connect to a potentially newly formed cluster");
                `rm -f /var/lib/mysql/grastate.dat`;
                fork_launch_mysql("join-new-cluster");
            }
        }
    }
    else {
        $logger->info("There isn't a ping quorum yet nor a server with an alive database, will wait until the majority of the servers are alive.");
        sleep $WAIT_TIME_ALIVE;
        attempt_start();
    }
}

sub startup_dirty_shutdown {
    if(db_available()) {
        $logger->info("There is a peer with an alive DB. Will attempt to connect to the cluster");
        fork_launch_mysql("db-peer-available");
    }
    else {
        $STARTED_BECAUSE = "attempting-to-get-quorum";
        if(pf::cluster::cluster_index() == 0) {
            if(!_check_pid($QUORUM_MGMT_SERVER_PID)) {
                $logger->info("There is a gvwstate and we're the first server. Will start the management quorum server to find the state of all servers.");
                # this below will fork, so the process will continue
                quorum_management_server();
            }
        }

        if(!_check_pid($QUORUM_CLIENT_SERVER_PID)) {
            $logger->info("Starting client quorum server.");
            quorum_client_server();
        }

        if($gvwstate_cache->get("gvwstate-should-start")) {
            $logger->info("Ready to start.");
            fork_launch_mysql("gvwstate-should-start");
        } else {
            # All server (including the first one), must report their state to the master
            $logger->info("Not ready to startup, reporting state to master cluster server");
            send_info_to_quorum_server();
        }
    }
}

sub act_on_quorum_server_data {
    my $info = get_gvwstate_info();
    my $missing = scalar(@cluster_servers) - scalar(keys(%$info));
    if ($missing == 0) {
        $logger->info("Collected quorum information from all servers");
        my $latest_host;
        my $latest_timestamp = 0;
        while(my ($hostname, $server_info) = each(%$info)) {
            if($server_info->{gvwstate_timestamp} > $latest_timestamp) {
                $latest_host = $hostname;
                $latest_timestamp = $server_info->{gvwstate_timestamp};
            }
        }
        $logger->info("Latest info comes from $latest_host with a timestamp of $latest_timestamp");
        continue unless(defined($latest_host));

        my @alive;
        my $latest_info = $info->{$latest_host};
        while(my ($hostname, $server_info) = each(%$info)) {
            my $uuid = $server_info->{gvwstate_uuid};
            # If the server should be running and its not currently running
            if(any { $_ eq $uuid } @{$latest_info->{gvwstate_members}}) {
                if(test_db($server_info->{server_mgmt_ip})) {
                    $logger->info("Server $hostname is already up");
                    push @alive, $hostname;
                } 
                else {
                    $logger->info("$hostname was part of the latest gvwstate. Will instruct it to start.");
                    send_to_quorum_client($server_info->{server_mgmt_ip}, {should_start => 1});
                }
            }
            else {
                $logger->info("$hostname wasn't part of the latest gvwstate. Will instruct it to stay off for now.");
                send_to_quorum_client($server_info->{server_mgmt_ip}, {should_start => 0});
            }
        }
        if(scalar(@alive) == scalar(keys(%$info))) {
            $logger->info("All servers are started. Stopping quorum processes");
            $gvwstate_cache->clear();
            kill(SIGTERM, $QUORUM_MGMT_SERVER_PID) if($QUORUM_MGMT_SERVER_PID);
        }
    }
    else {
        $logger->info("Still missing quorum information for $missing servers. Following servers have reported: ".join(',', keys(%$info)));
    }
}

sub _check_pid {
    my ($pid) = @_;
    return $pid && kill(0, $pid);
}

=head2 attempt_start

Attempt a startup of MySQL based on the current state of things

Refer to the clustering guide for details on how this works.

=cut

sub attempt_start {
    # Just start it without anything special if we're in standalone mode
    if(!$cluster_enabled) {
        fork_launch_mysql("standalone");
    }
    # MySQL isn't running but there is a gvwstate
    elsif(!_check_pid($MYSQLD_SPAWNER_PID) && -f "/var/lib/mysql/gvwstate.dat") {
        startup_dirty_shutdown();
    }
    else {
        startup_clean_shutdown();
    }
}

if(pf::cluster::is_in_maintenance) {
    my $msg = "Not starting because this node is in maintenance mode";
    print STDERR "$msg\n";
    $logger->error($msg);
    exit;
}

$gvwstate_cache->clear();
attempt_start();
while($RUNNING){
    # Quorum server is running so we're attempting to get a quorum
    if(_check_pid($QUORUM_MGMT_SERVER_PID)) {
        act_on_quorum_server_data();
    }

    if(!_check_pid($MYSQLD_SPAWNER_PID)) {
        print "Failed starting with mode: $STARTED_BECAUSE \n";
        $failed_counts->{$STARTED_BECAUSE} //= 0;
        $failed_counts->{$STARTED_BECAUSE} ++;

        print "MariaDB is not alive \n";
        attempt_start();
    }
    elsif($cluster_enabled and test_db(pf::cluster::current_server()->{management_ip})) {
        $logger->info("Successful test to the DB. Flushing failure counts.");
        $failed_counts = {};
    }
    sleep 1;
}


END {
    deletepid();
}

exit(0);

=head2 normal_sighandler

Cleanup and stop processing when geting a signal

=cut

sub normal_sighandler {
    $RUNNING = 0;
    if(!$IS_CHILD) {
        # Don't listen to child signals anymore when cleaning up
        $SIG{CHLD} = "IGNORE";

        kill(SIGTERM, $MYSQLD_SPAWNER_PID) if($MYSQLD_SPAWNER_PID);
        kill(SIGTERM, $QUORUM_MGMT_SERVER_PID) if($QUORUM_MGMT_SERVER_PID);
        kill(SIGTERM, $QUORUM_CLIENT_SERVER_PID) if($QUORUM_CLIENT_SERVER_PID);
        `pkill mysqld`;
        deletepid();
        $logger->debug( "pfmariadb caught SIG" . $_[0] . " - terminating" );
    }
}

=head2 child_sighandler

When a child dies, we cleanup any leftover mysqld processes

=cut

sub child_sighandler {
    local ($!, $?);

    while(1) {
        my $child = waitpid(-1, WNOHANG);
        last unless $child > 0;
    }
}
